# KeyDB客户端处理

本文档从网络层的角度提供了有关KeyDB如何处理客户端的信息：这里将介绍连接、超时、缓冲区和其他类似的主题。

本文档中包含的信息**仅适用于KeyDB版本2.6或更高版本**

## 如何接受客户端连接

KeyDB接受配置的侦听TCP端口和Unix套接字（如果启用）上的客户端连接。当接受新的客户端连接时，将执行以下操作：

    * 因为KEYDB使用多路复用和非阻塞I/O.，所以客户端套接字被置于非阻塞状态。
    * 设置TCP_NODELAY选项是为了确保我们的连接没有延迟。
    * 创建一个可读的文件事件，以便KeyDB能够在套接字上读取新数据时立即收集客户端查询

客户机初始化后，KeyDB检查我们是否已经达到可以同时处理的客户机数量的限制（这是使用maxclients配置指令配置的）。

如果无法接受当前客户机，因为客户机的最大数量已经被接受，KeyDB尝试向客户端发送错误，以便使其意识到这种情况，并立即关闭连接。
即使KeyDB立即关闭连接，错误消息也能够到达客户端，因为新的套接字输出缓冲区通常足够大，可以包含错误，因此内核将处理错误的传输。

## 客户的服务顺序

顺序由客户端套接字文件描述符号和内核报告事件的顺序的组合决定，因此该顺序将被视为未指定。

然而，KeyDB在为客户服务时会执行以下两项操作：

    * 它只在每次有新的东西要从客户机套接字读取时执行一次read()系统调用，以确保如果我们连接了多个客户机，并且有一些客户机要求很高的速率发送查询，则其他客户机不会受到惩罚，也不会出现不良的延迟数字。
    * 但是，一旦从客户端读取新数据，当前缓冲区中包含的所有查询都将按顺序处理。这改善了局部性，不需要第二次迭代来查看是否有客户端需要一些处理时间。

## 最大客户数

在KeyDB 2.4中，对于可同时处理的客户端的最大数量，存在硬编码限制。

在KeyDB 2.6中，这个限制是动态的：默认情况下，它被设置为10000个客户端，除非keydb.conf中的maxclients指令另有说明。

但是，KeyDB用内核检查我们能够打开的文件描述符的最大数目（检查软限制）。
如果限制小于我们想要处理的最大客户数，加上32（即内部使用的文件描述符KEYDB储备的数量），那么最大客户机的数量由KEYDB修改，
以匹配在当前操作系统限制下我们真正能够处理的客户数量。

当无法配置配置的最大客户端数量时，在启动时记录该条件，如以下示例所示：

    $ ./keydb-server --maxclients 100000
    [41422] 23 Jan 11:28:33.179 # Unable to set the max number of files limit to 100032 (Invalid argument), setting the max clients configuration to 10112.

当KeyDB被配置为处理特定数量的客户端时，最好确保操作系统对每个进程的文件描述符的最大数量限制也相应地设置。

在Linux下，这些限制可以在当前会话中设置，也可以通过以下命令设置为系统范围内的设置：

    ulimit-Sn 100000 #只有当硬限制足够大时，这才有效。
    sysctl -w fs.file max=100000

## 输出缓冲区限制

KeyDB需要为每个客户机处理一个可变长度的输出缓冲区，因为一个命令可以生成大量需要传输到客户机的数据。

然而，客户端可以发送更多的命令来产生更多的输出，以更快的速度服务，KEYDB可以将现有的输出发送给客户端。
在Pub/Sub客户机中尤其如此，以防客户机无法足够快地处理新消息。

这两种情况都会导致客户端输出缓冲区增长并消耗越来越多的内存。因此，默认情况下KeyDB为不同类型的客户机设置输出缓冲区大小限制。
当达到限制时，客户端连接将关闭，事件将记录在KeyDB日志文件中。

KeyDB有两种使用限制：

**硬限制**是一个固定的限制，当达到该限制时，KeyDB将尽快关闭客户端连接。
**软限制**是一个取决于时间的限制，例如，每10秒32兆字节的软限制意味着，如果客户端的输出缓冲区连续10秒大于32兆字节，则连接将关闭。

不同类型的客户有不同的默认限制：

**普通客户端** 默认限制为0，这意味着根本没有限制，因为大多数普通客户机使用阻塞实现发送单个命令，并在发送下一个命令之前等待完全读取应答，
因此在普通客户机的情况下，总是不希望关闭连接。
**Pub/Sub客户端** 默认硬限制为32兆字节，软限制为每60秒8兆字节。
**从节点** 默认硬限制为256兆字节，软限制为64兆字节 每60秒。

可以在运行时使用CONFIG SET命令或使用KeyDB配置文件keydb.conf以永久方式更改限制。有关如何设置限制的详细信息，请参阅KeyDB发行版中的keydb.conf示例。

## 查询缓冲区硬限制

每个客户机还受到查询缓冲区限制。这是一个不可配置的硬限制，当客户端查询缓冲区（我们用来从客户端累积命令的缓冲区）达到1GB时，
它将关闭连接，实际上这只是一个极端限制，以避免在客户端或服务器软件出现错误时服务器崩溃。

## 客户端超时

默认情况下，如果客户端空闲了许多秒，则最新版本的KeyDB不会关闭与客户端的连接：该连接将永远保持打开状态。
但是，如果不喜欢此行为，可以配置超时，以便如果客户端空闲超过指定的秒数，则将关闭客户端连接。
您可以通过keydb.conf或使用CONFIG SET timeout<value>配置此限制。
请注意，超时仅适用于普通客户端，而不适用于发布/订阅客户端，因为发布/订阅连接是一种推送式连接，因此空闲的客户端是正常的。
即使默认情况下连接不受超时限制，设置超时也有两种情况：

    * 任务关键型应用程序，其中客户端软件中的错误可能使KeyDB服务器充满空闲连接，从而导致服务中断。
    * 作为一种调试机制，以便在客户端软件中的错误使服务器充满空闲连接时能够与服务器连接，从而无法与服务器交互。

超时不能被认为是非常精确的：KeyDB避免设置计时器事件或运行O（N）算法来检查空闲客户机，因此检查会不时地以增量方式执行。
这意味着，当超时设置为10秒时，可能会关闭客户端连接，例如，如果同时连接了多个客户端，则会在12秒后关闭。

## CLIENT 命令

KeyDB client命令允许检查每个连接的客户端的状态、终止特定的客户端、将名称设置为连接。如果按比例使用KeyDB，它是一个非常强大的调试工具。

CLIENT LIST 用于获取连接的客户端及其状态的列表：

    KeyDB 127.0.0.1:6379> client list
    addr=127.0.0.1:52555 fd=5 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client
    addr=127.0.0.1:52787 fd=6 name= age=6 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping

在上面的示例会话中，两个客户端连接到KeyDB服务器。几个最有趣的字段含义如下：

    * addr：客户端地址，即客户端IP和用于连接KeyDB服务器的远程端口号。
    * fd：客户端套接字文件描述符号。
    * name：客户端SETNAME设置的客户端名称。
    * age：连接存在的秒数。
    * idle：连接空闲的秒数。
    * flags：客户机的类型（N表示普通客户机，检查标志的完整列表）。
    * omem：客户端用于输出缓冲区的内存量。
    * cmd：最后执行的命令。

有关字段及其含义的完整列表，请参阅客户机列表文档。
一旦有了客户机列表，就可以使用client KILL命令将客户机地址指定为参数，轻松地关闭与客户机的连接。
命令CLIENT set name和CLIENT GETNAME可用于设置和获取连接名。从KeyDB 4.0开始，客户机名称显示在SLOWLOG输出中，这样就更容易识别产生延迟问题的客户机。

## TCP keepalive

最新版本的KeyDB（3.2或更高版本）在默认情况下启用了TCP keepalive（SO_keepalive socket选项），并将其设置为大约300秒。
此选项可用于检测死机对等机（即使看起来已连接，也无法连接到的客户端）。
此外，如果客户端和服务器之间存在网络设备，需要查看一些流量才能打开连接，则该选项将防止意外的连接关闭事件。



