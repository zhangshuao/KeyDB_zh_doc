# KeyDB 客户端 - 命令行界面

keydb-cli是keydb命令行界面，这是一个简单的程序，允许直接从终端向keydb发送命令并读取服务器发送的回复。

它有两种主要模式：
一种是交互模式，其中有一个REPL（Read Eval Print Loop），用户在其中键入命令并获取回复；
另一种模式，其中命令作为keydb-cli的参数发送，执行并打印在标准输出上。

在交互模式下，keydb-cli具有基本的行编辑功能，可以提供良好的键入体验。

然而keydb-cli并不仅仅是这样。有一些选项可以用来启动程序，以便将其置于特殊模式，这样keydb-cli肯定可以执行更复杂的任务，
例如模拟从服务器并打印从主服务器接收的复制流，检查keydb服务器的延迟，并显示延迟样本和频率的统计数据，甚至ASCII艺术谱图，以及许多其他东西。

本指南将涵盖keydb-cli的不同方面，从最简单的方面开始，到更高级的方面结束。

如果要广泛地使用keydb，或者已经使用了keydb，那么很可能会经常使用keydb-cli。
花点时间熟悉它可能是一个非常好的主意，您将看到，一旦您了解keydb命令行界面的所有技巧，您将更有效地使用keydb。

## 命令行使用

    只需运行命令并在标准输出上打印其答复，就如同键入命令以作为keydb-cli的独立参数执行一样简单：

    $ keydb-cli incr mycounter
    (integer) 7

命令的回答是"7"。由于keydb应答是类型化的（它们可以是字符串、数组、整数、NULL、错误等等），所以您可以看到括号之间的应答类型。但是，当keydb-cli的输出必须用作另一个命令的输入，或者当我们希望将其重定向到文件中时，这并不是一个好主意。

实际上，keydb-cli只显示附加信息，当它检测到标准输出是tty（基本上是一个终端）时，这些信息可以提高人类的可读性。
否则，它将自动启用原始输出模式，如下例所示：

    $ keydb-cli incr mycounter > /tmp/output.txt
    $ cat /tmp/output.txt
    8

这一次（整数）从输出中被省略，因为CLI检测到输出不再写入终端。即使在终端上也可以使用--raw选项强制原始输出:

    $ keydb-cli --raw incr mycounter
    9

类似地，在向文件或管道中写入其他命令时，可以使用--no-raw强制执行可读输出。

### Host, port, password 和 database
 
默认情况下，keydb-cli连接到127.0.0.1端口6379处的服务器。如您所料，您可以使用命令行选项轻松更改此设置。
要指定不同的主机名或IP地址，请使用-h。要设置不同的端口，请使用-p。

    $ keydb-cli -h keydb15.localnet.org -p 6390 ping
    PONG

如果您的实例受密码保护，-a <password>选项将执行身份验证，以满足显式使用AUTH命令的需要：

    $ keydb-cli -a myUnguessablePazzzzzword123 ping
    PONG

最后，可以使用-n <dbnum>选项发送一个命令，该命令对数据库号（而不是默认的0号）进行操作：

    $ keydb-cli flushall
    OK
    $ keydb-cli -n 1 incr a
    (integer) 1
    $ keydb-cli -n 1 incr a
    (integer) 2
    $ keydb-cli -n 2 incr a
    (integer) 1
   
还可以使用 -u <uri>选项和有效的uri来提供部分或全部信息：

    $ keydb-cli -u keydb://p%40ssw0rd@keydb-16379.hosted.com:16379/0 ping
    PONG

### 从其他程序获取输入

有两种方法可以使用keydb-cli从其他命令（基本上是从标准输入）获取输入。一个是使用我们从stdin读取的有效载荷作为最后一个参数。
例如，为了将keydb key设置为文件/etc/services（如果是我的计算机）的内容，我可以使用-x选项：

    $ keydb-cli -x set foo < /etc/services
    OK
    $ keydb-cli getrange foo 0 50
    "#\n# Network services, Internet style\n#\n# Note that "

正如您在上述会话的第一行中看到的，没有指定SET命令的最后一个参数。参数只是设置foo，没有我想要的键的实际值。
相反，指定了-x选项，并将文件重定向到CLI的标准输入。因此，输入被读取，并用作命令的最终参数。这对编写脚本很有用。
另一种方法是为keydb-cli提供一系列写入文本文件的命令：

    $ cat /tmp/commands.txt
    set foo 100
    incr foo
    append foo xxx
    get foo
    $ cat /tmp/commands.txt | keydb-cli
    OK
    (integer) 101
    (integer) 6
    "101xxx"

commands.txt中的所有命令都由keydb-cli一个接一个地执行，就好像它们是由用户交互式键入的一样。
如果需要，可以在文件中引用字符串，以便可以在其中包含空格、换行符或其他特殊字符的单个参数：

    $ cat /tmp/commands.txt
    set foo "This is a single argument"
    strlen foo
    $ cat /tmp/commands.txt | keydb-cli
    OK
    (integer) 25

### 连续运行同一命令

在用户选择的两次执行之间暂停的情况下，可以执行指定次数的同一命令。这在不同的上下文中很有用，
例如，当我们想要连续监视一些关键内容或信息字段输出时，或者当我们想要模拟一些重复的写入事件时（比如每5秒将一个新项推送到一个列表中）。
此功能由两个选项控制：-r <count> 和 -i <delay>。 第一个状态是运行一个命令的次数，第二个状态是配置不同命令调用之间的延迟（以秒为单位）（能够指定小数，例如0.1，以表示100毫秒）。
默认情况下，间隔（或延迟）设置为0，因此命令将尽快执行：

    $ keydb-cli -r 5 incr foo
    (integer) 1
    (integer) 2
    (integer) 3
    (integer) 4
    (integer) 5

要永远运行同一命令，请使用-1作为计数。因此，为了监视RSS内存大小，可以使用如下命令：

    $ keydb-cli -r -1 -i 1 INFO | grep rss_human
    used_memory_rss_human:1.38M
    used_memory_rss_human:1.38M
    used_memory_rss_human:1.38M
    ... a new line will be printed each second ...

### 使用keydb-cli大量插入数据

使用keydb-cli进行大规模插入将在单独的页面中介绍，因为这本身就是一个值得讨论的主题。请参阅我们的批量插入指南。

### CSV输出

有时，您可能希望使用keydb-cli以便将数据从keydb快速导出到外部程序。这可以使用CSV（逗号分隔值）输出功能来完成：

    $ keydb-cli lpush mylist a b c d
    (integer) 4
    $ keydb-cli --csv lrange mylist 0 -1
    "d","c","b","a"

目前不可能像那样导出整个数据库，而只能使用CSV输出运行单个命令。

### 运行Lua脚本

keydb-cli广泛支持使用Lua脚本的新Lua调试工具，该工具从keydb 3.2开始提供。有关此功能，请参阅keydb Lua调试器文档。

但是，即使不使用调试器，也可以使用keydb-cli从文件中运行脚本，与在shell中以交互方式键入脚本或作为参数相比，这种方式更舒适：

    $ cat /tmp/script.lua
    return keydb.call('set',KEYS[1],ARGV[1])
    $ keydb-cli --eval /tmp/script.lua foo , bar
    OK

keydb EVAL命令将脚本使用的键列表和其他非键参数作为不同的数组。当调用EVAL时，您将提供key数作为一个数字。
但是，使用keydb-cli并使用上面的--eval选项，不需要显式地指定键的数量。相反，它使用了用逗号分隔键和参数的约定。
这就是为什么在上面的调用中你看到foo，bar作为参数。

所以foo将填充KEYS数组，并禁止ARGV数组。

在编写简单脚本时，--eval选项非常有用。对于更复杂的工作，使用Lua调试器肯定更舒服。
这两种方法可以混合使用，因为调试器还使用从外部文件执行脚本。

## 交互模式

到目前为止，我们探索了如何将keydb CLI用作命令行程序。这对于脚本和某些类型的测试非常有用，但是大多数人将在keydb-cli中使用其交互模式花费大部分时间。
在交互模式下，用户在提示下键入keydb命令。该命令被发送到服务器，进行处理，然后将回复解析回来，并呈现为更简单的形式以供阅读。
在交互模式下运行CLI不需要什么特别的东西—只需在不带任何参数的情况下启动它，就可以：

    $ keydb-cli
    127.0.0.1:6379> ping
    PONG

字符串 127.0.0.1:6379> 是提示。它提醒您已连接到给定的keydb实例。
当您连接到的服务器发生更改时，或者当您在一个与0号数据库不同的数据库上操作时，提示将发生更改：

    127.0.0.1:6379> select 2
    OK
    127.0.0.1:6379[2]> dbsize
    (integer) 1
    127.0.0.1:6379[2]> select 0
    OK
    127.0.0.1:6379> dbsize
    (integer) 503

### 处理连接和重新连接

在交互模式下使用connect命令，通过指定要连接到的主机名和端口，可以连接到其他实例：

    127.0.0.1:6379> connect metal 6379
    metal:6379> ping
    PONG

如您所见，提示会相应地更改。如果用户尝试连接到无法访问的实例，keydb-cli将进入断开连接模式并尝试重新连接每个新命令：

    127.0.0.1:6379> connect 127.0.0.1 9999
    Could not connect to keydb at 127.0.0.1:9999: Connection refused
    not connected> ping
    Could not connect to keydb at 127.0.0.1:9999: Connection refused
    not connected> ping
    Could not connect to keydb at 127.0.0.1:9999: Connection refused
    
通常在检测到断开连接后，CLI总是尝试透明地重新连接：如果尝试失败，它将显示错误并进入断开连接状态。
以下是断开和重新连接的示例：

    127.0.0.1:6379> debug restart
    Could not connect to keydb at 127.0.0.1:6379: Connection refused
    not connected> ping
    PONG
    127.0.0.1:6379> (now we are connected again)

执行重新连接时，keydb-cli会自动重新选择所选的最后一个数据库号。但是，有关连接的所有其他状态都将丢失，例如，如果我们正在处理事务，则事务的状态为：

    $ keydb-cli
    127.0.0.1:6379> multi
    OK
    127.0.0.1:6379> ping
    QUEUED
    
    ( here the server is manually restarted )
    
    127.0.0.1:6379> exec
    (error) ERR EXEC without MULTI

在交互模式下使用CLI进行测试时，这通常不是问题，但您应该知道这一限制.

### 编辑、历史和完成

您可以通过按箭头键（向上和向下）访问已执行命令的历史记录，以避免重复键入命令。
历史记录将在CLI重新启动之间保留，保存在用户主目录中名为.keydbcli_history的文件中，由home环境变量指定。
可以通过设置keydbCLI_HISTFILE环境变量来使用不同的历史文件名，并通过将其设置为/dev/null来禁用它。

CLI还可以通过按TAB键执行命令名完成，如下例所示：

    127.0.0.1:6379> Z<TAB>
    127.0.0.1:6379> ZADD<TAB>
    127.0.0.1:6379> ZCARD<TAB>

### 运行同一命令N次

通过将命令名预先编号可以多次运行相同的命令：

    127.0.0.1:6379> 5 incr mycounter
    (integer) 1
    (integer) 2
    (integer) 3
    (integer) 4
    (integer) 5

### 显示有关keydb命令的帮助

keydb有许多命令，有时在测试时，可能记不住参数的确切顺序。keydb-cli使用help命令为大多数keydb命令提供联机帮助。
该命令可以使用两种形式：

    * help @<category> 显示有关给定类别的所有命令。 分类是: @generic, @list, @set, @sorted_set, @hash, @pubsub, @transactions, @connection, @server, @scripting, @hyperloglog.
    * help <commandname> 显示作为参数给定的命令的特定帮助。

例如，要显示PFADD命令的帮助，请使用：

127.0.0.1:6379> help PFADD

PFADD key element[元素…]摘要：将指定元素添加到指定的超日志中。自：2.8.9
请注意，帮助也支持制表符完成。

### 清除终端屏幕

在交互模式下使用clear命令可以清除终端屏幕。

## 特殊操作模式

到目前为止，我们看到了keydb-cli的两种主要模式。

    * keydb命令的命令行执行。
    * 交互式"REPL-like"用法。

然而，CLI执行与KEYDB相关的其他辅助任务，这些任务将在下一节中解释：

    * 显示keydb服务器的连续状态的监视工具。
    * 扫描keydb数据库以查找非常大的key。
    * 带模式匹配的键空间扫描仪。
    * 作为发布/订阅客户订阅频道。
    * 监视执行到keydb实例中的命令。
    * 以不同的方式检查keydb服务器的延迟。
    * 正在检查本地计算机的计划程序延迟。
    * 从本地远程keydb服务器传输RDB备份。
    * 作为keydb从机来显示从机接收的内容。
    * 模拟LRU工作负载以显示键命中的统计信息。
    * Lua调试器的客户端。

### 连续统计模式

这可能是keydb-cli鲜为人知的特性之一，也是实时监视keydb实例非常有用的特性之一。
要启用此模式，请使用--stat选项。输出非常清楚该模式下的CLI行为：

    $ keydb-cli --stat
    ------- data ------ --------------------- load -------------------- - child -
    keys       mem      clients blocked requests            connections
    506        1015.00K 1       0       24 (+0)             7
    506        1015.00K 1       0       25 (+1)             7
    506        3.40M    51      0       60461 (+60436)      57
    506        3.40M    51      0       146425 (+85964)     107
    507        3.40M    51      0       233844 (+87419)     157
    507        3.40M    51      0       321715 (+87871)     207
    508        3.40M    51      0       408642 (+86927)     257
    508        3.40M    51      0       497038 (+88396)     257

在这种模式下，每秒会打印一行有用的信息以及旧数据点之间的差异。您可以很容易地了解内存使用情况、连接的客户端等等。

在本例中，-i<interval>选项用作修改器，以更改发出新行的频率。默认值为1秒。

### 扫描大键

在此特殊模式下，keydb-cli用作key空间分析器。它扫描数据集以查找大键，同时还提供有关数据集所包含的数据类型的信息。
此模式通过--bigkeys选项启用，并生成相当详细的输出：

    $ keydb-cli --bigkeys
    
    # Scanning the entire keyspace to find biggest keys as well as
    # average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec
    # per 100 SCAN commands (not usually needed).
    
    [00.00%] Biggest string found so far 'key-419' with 3 bytes
    [05.14%] Biggest list   found so far 'mylist' with 100004 items
    [35.77%] Biggest string found so far 'counter:__rand_int__' with 6 bytes
    [73.91%] Biggest hash   found so far 'myobject' with 3 fields
    
    -------- summary -------
    
    Sampled 506 keys in the keyspace!
    Total key length in bytes is 3452 (avg len 6.82)
    
    Biggest string found 'counter:__rand_int__' has 6 bytes
    Biggest   list found 'mylist' has 100004 items
    Biggest   hash found 'myobject' has 3 fields
    
    504 strings with 1403 bytes (99.60% of keys, avg size 2.78)
    1 lists with 100004 items (00.20% of keys, avg size 100004.00)
    0 sets with 0 members (00.00% of keys, avg size 0.00)
    1 hashs with 3 fields (00.20% of keys, avg size 3.00)
    0 zsets with 0 members (00.00% of keys, avg size 0.00)

在输出的第一部分中，报告遇到的每个新键都比以前遇到的更大的键（属于同一类型）大。
summary部分提供关于keydb实例内数据的一般统计信息。

程序使用SCAN命令，因此可以在不影响操作的情况下对繁忙的服务器执行该命令，但是可以使用-i选项来限制对每100个请求的key的指定秒数的扫描过程。
例如，-i 0.1将大大降低程序的执行速度，但也会将服务器上的负载减少到很小的程度。

请注意，摘要还以更干净的形式报告每次找到的最大key。最初的输出只是为了在一个非常大的数据集上运行时尽快提供一些有趣的信息。

### 获取key列表

也可以扫描key空间，同样不阻塞keydb服务器（在使用KEYS *之类的命令时确实会发生这种情况），打印所有key名称，或者根据特定模式过滤它们。
与--bigkeys选项类似，此模式使用SCAN命令，因此如果数据集正在更改，则可能会多次报告key，但如果自迭代开始以来该key一直存在，则不会丢失任何key。
因为它使用的命令是--scan。

    $ keydb-cli --scan | head -10
    key-419
    key-71
    key-236
    key-50
    key-38
    key-458
    key-453
    key-499
    key-446
    key-371

注意，head -10 只用于打印输出的第一行。
扫描可以使用SCAN命令的底层模式匹配功能 和 --pattern 选项。

    $ keydb-cli --scan --pattern '*-11*'
    key-114
    key-117
    key-118
    key-113
    key-115
    key-112
    key-119
    key-11
    key-111
    key-110
    key-116

通过wc命令管道输出可用于按键名计算特定类型的对象：

    $ keydb-cli --scan --pattern 'user:*' | wc -l
    3829433

### Pub/Sub 模式

CLI可以使用publish命令在keydb Pub/Sub通道中发布消息。这是意料之中的，因为PUBLISH命令与任何其他命令都非常相似。
订阅通道以接收消息是不同的—在这种情况下，我们需要阻塞和等待消息，因此这在keydb-cli中被实现为一种特殊模式。
与其他特殊模式不同，此模式不是通过使用特殊选项启用的，而是通过使用SUBSCRIBE或PSUBSCRIBE命令（在交互或非交互模式下）启用的：

    $ keydb-cli psubscribe '*'
    Reading messages... (press Ctrl-C to quit)
    1) "psubscribe"
    2) "*"
    3) (integer) 1

reading messages消息显示我们进入了Pub/Sub模式。当另一个客户机在某个通道中发布某些消息时（如您可以使用keydb-cli PUBLISH mychannel mymessage），
Pub/Sub模式下的cli将显示如下内容：

    1) "pmessage"
    2) "*"
    3) "mychannel"
    4) "mymessage"

这对于调试发布/订阅问题非常有用。退出PUB/SUB模式只需处理CTRL C

### 在keydb中执行的监视命令

与Pub/Sub模式类似，使用监控模式后，将自动进入监控模式。它将打印keydb实例接收到的所有命令：

    $ keydb-cli monitor
    OK
    1460100081.165665 [0 127.0.0.1:51706] "set" "foo" "bar"
    1460100083.053365 [0 127.0.0.1:51707] "get" "foo"

注意，可以使用管道输出，因此可以使用grep等工具监视特定的模式。

### 监视keydb实例的延迟

keydb通常用于延迟非常关键的上下文中。延迟涉及应用程序中的多个移动部分，从客户端库到网络堆栈，再到keydb实例本身。

CLI具有用于研究KEYDB实例的潜伏期和理解延迟的最大值、平均值和分布的多个设施。

基本的延迟检查工具是--latency选项。使用此选项，CLI运行一个循环，其中PING命令被发送到keydb实例，并测量获得回复的时间。
这种情况每秒发生100次，并且在控制台中实时更新统计信息：

    $ keydb-cli --latency
    min: 0, max: 1, avg: 0.19 (427 samples)

统计数据以毫秒为单位。通常，由于运行keydb-cli的系统本身的内核调度程序所导致的延迟，很快实例的平均延迟往往会被高估一点，因此上面0.19的平均延迟可能很容易是0.01或更低。
然而，这通常不是一个大问题，因为我们对毫秒或毫秒以上的事件感兴趣。

有时，研究最大和平均潜伏期在时间上如何演变是有用的。--latency history选项用于此目的：它的工作方式与--latency完全相同，但每15秒（默认情况下）就会从头开始一个新的采样会话：

    $ keydb-cli --latency-history
    min: 0, max: 1, avg: 0.14 (1314 samples) -- 15.01 seconds range
    min: 0, max: 1, avg: 0.18 (1299 samples) -- 15.00 seconds range
    min: 0, max: 1, avg: 0.20 (113 samples)^C

您可以使用 -i <interval>选项更改采样会话的长度。

最先进的延迟研究工具，但对于没有经验的用户来说，也有点难以解释，就是能够使用彩色终端显示一系列的延迟。
您将看到一个彩色输出，它指示样本的不同百分比，以及指示不同延迟数字的不同ASCII字符。使用--latency dist选项启用此模式：

    $ keydb-cli --latency-dist
    (output not displayed, requires a color terminal, try it!)

keydb-cli中还实现了另一个非常不寻常的延迟工具。它不检查keydb实例的延迟，而是检查运行keydb-cli的计算机的延迟。你可能会问什么延迟？内核调度程序固有的延迟，虚拟化实例的管理程序，等等。

我们称之为内在延迟，因为它对程序员来说是不透明的。如果keydb实例的延迟不好，而不考虑所有可能是源原因的明显原因，那么值得检查一下，在运行keydb服务器的系统中直接以这种特殊模式运行keydb-cli，您的系统能做的最好的事情是什么。

通过测量内在延迟，您知道这是基线，keydb不能超过您的系统。要在此模式下运行CLI，请使用--intrinal latency <test time>。
测试的时间以秒为单位，并指定keydb-cli应检查其当前运行的系统的延迟时间。

    $ ./keydb-cli --intrinsic-latency 5
    Max latency so far: 1 microseconds.
    Max latency so far: 7 microseconds.
    Max latency so far: 9 microseconds.
    Max latency so far: 11 microseconds.
    Max latency so far: 13 microseconds.
    Max latency so far: 15 microseconds.
    Max latency so far: 34 microseconds.
    Max latency so far: 82 microseconds.
    Max latency so far: 586 microseconds.
    Max latency so far: 739 microseconds.
    
    65433042 total runs (avg latency: 0.0764 microseconds / 764.14 nanoseconds per run).
    Worst run took 9671x longer than the average latency.

重要提示：此命令必须在要在其上运行keydb server的计算机上执行，而不是在其他主机上执行。
它甚至不连接到keydb实例，只在本地执行测试。

在上述情况下，我的系统在最坏情况下的延迟不能超过739微秒，因此我可以期望某些查询在不到1毫秒的时间内运行。

### RDB文件的远程备份

在keydb复制的第一次同步期间，主服务器和从服务器以RDB文件的形式交换整个数据集。
keydb-cli利用此功能可提供远程备份功能，允许将RDB文件从任何keydb实例传输到运行keydb-cli的本地计算机。
要使用此模式，请使用 --rdb <dest filename> 选项调用CLI：

    $ keydb-cli --rdb /tmp/dump.rdb
    SYNC sent to master, writing 13256 bytes to '/tmp/dump.rdb'
    Transfer finished with success.

这是确保对keydb实例进行灾难恢复RDB备份的简单而有效的方法。但是，在脚本或cron作业中使用此选项时，请确保检查命令的返回值。
如果非零，则会发生如下示例中的错误：

    $ keydb-cli --rdb /tmp/dump.rdb
    SYNC with master failed: -ERR Can't SYNC while not connected with my master
    $ echo $?
    1

### Slave模式

CLI的从模式是一个高级特性，对keydb开发人员和调试操作非常有用。
它允许检查主服务器在复制流中向其从服务器发送的内容，以便将写操作传播到其副本。
选项名是简单的--slave。这就是它的工作原理：

    $ keydb-cli --slave
    SYNC with master, discarding 13256 bytes of bulk transfer...
    SYNC done. Logging commands from master.
    "PING"
    "SELECT","0"
    "set","foo","bar"
    "PING"
    "incr","mycounter"

该命令首先丢弃第一次同步的RDB文件，然后以CSV格式记录接收到的每个命令。

如果您认为某些命令没有在从机中正确复制，这是检查正在发生的情况的好方法，也是改进错误报告的有用信息。

### 执行LRU模拟

keydb通常用作LRU逐出的缓存。根据键的数量和为缓存分配的内存量（通过maxmemory指令指定），缓存命中和未命中的数量将发生变化。
有时，模拟命中率对于正确配置缓存非常有用。

CLI有一个特殊的模式，它使用请求模式中80-20%的幂律分布来模拟GET和SET操作。
这意味着20%的key将被请求80%的次数，这是缓存场景中的常见分布。

理论上，考虑到请求的分布和keydb内存开销，应该可以用数学公式解析地计算命中率。
但是，可以用不同的LRU设置（样本数）和LRU的实现来配置日志文件。类似地，每个key的内存量可能在不同版本之间发生变化。
这就是为什么构建这个工具的原因：它的主要动机是测试keydb的LRU实现的质量，但是现在对于测试给定版本如何使用部署时考虑的设置也很有用。

要使用此模式，需要指定测试中的key数量。您还需要配置一个maxmemory设置，作为第一次尝试是有意义的。

重要提示：在KEYDB配置中配置maxmemory设置是至关重要的：如果没有最大内存使用上限，命中将最终为100%，因为所有的key都可以存储在内存中。
或者，如果您指定了太多的key，没有最大内存，最终将使用所有的计算机RAM。
还需要配置适当的maxmemory策略，大多数情况下，您需要的是allkeys-lru。

在下面的示例中，我将内存限制配置为100MB，并使用1000万个key进行LRU模拟。

警告：测试使用管道，会给服务器带来压力，不要将其用于生产实例。

    $ ./keydb-cli --lru-test 10000000
    156000 Gets/sec | Hits: 4552 (2.92%) | Misses: 151448 (97.08%)
    153750 Gets/sec | Hits: 12906 (8.39%) | Misses: 140844 (91.61%)
    159250 Gets/sec | Hits: 21811 (13.70%) | Misses: 137439 (86.30%)
    151000 Gets/sec | Hits: 27615 (18.29%) | Misses: 123385 (81.71%)
    145000 Gets/sec | Hits: 32791 (22.61%) | Misses: 112209 (77.39%)
    157750 Gets/sec | Hits: 42178 (26.74%) | Misses: 115572 (73.26%)
    154500 Gets/sec | Hits: 47418 (30.69%) | Misses: 107082 (69.31%)
    151250 Gets/sec | Hits: 51636 (34.14%) | Misses: 99614 (65.86%)
    
程序每秒显示统计数据。如您所见，在开始的几秒钟内，缓存开始填充。稍后，未命中率会稳定到我们在很长一段时间内可以预期的实际数字:

    120750 Gets/sec | Hits: 48774 (40.39%) | Misses: 71976 (59.61%)
    122500 Gets/sec | Hits: 49052 (40.04%) | Misses: 73448 (59.96%)
    127000 Gets/sec | Hits: 50870 (40.06%) | Misses: 76130 (59.94%)
    124250 Gets/sec | Hits: 50147 (40.36%) | Misses: 74103 (59.64%)

对于我们的用例，59%的愤怒小姐是不可接受的。所以我们知道100MB的内存是不够的。
让我们试试半千兆字节。几分钟后，我们将看到输出稳定到下图：

    140000 Gets/sec | Hits: 135376 (96.70%) | Misses: 4624 (3.30%)
    141250 Gets/sec | Hits: 136523 (96.65%) | Misses: 4727 (3.35%)
    140250 Gets/sec | Hits: 135457 (96.58%) | Misses: 4793 (3.42%)
    140500 Gets/sec | Hits: 135947 (96.76%) | Misses: 4553 (3.24%)

所以我们知道，有了500MB，我们的key数量（1000万）和 发行量（80-20款）已经足够了。

