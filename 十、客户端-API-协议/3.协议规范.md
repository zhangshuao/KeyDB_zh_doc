# 协议规范

KeyDB客户端使用名为RESP（KeyDB序列化协议）的协议与KeyDB服务器通信。
虽然该协议是专门为KeyDB设计的，但它可以用于其他client-server软件项目。

RESP是以下两方面的折衷：

* 易于实现。
* 快速解析。
* 人类可读。

RESP可以序列化不同的数据类型，如整数、字符串、数组。还有一种特定类型的错误。
请求将作为表示要执行的命令参数的字符串数组从客户端发送到KeyDB服务器。KeyDB使用命令特定的数据类型进行响应。

RESP是二进制安全的，不需要处理从一个进程传输到另一个进程的大容量数据，因为它使用前缀长度来传输大容量数据。

注意：此处概述的协议仅用于client-server通信。KeyDB集群使用不同的二进制协议在节点之间交换消息。

## 网络层

客户端连接到KeyDB服务器，创建到端口6379的TCP连接。

虽然RESP在技术上是非TCP特定的，但在KeyDB上下文中，该协议仅用于TCP连接（或类似于Unix套接字的面向流的连接）。

## Request-Response 请求-响应模型

KeyDB接受由不同参数组成的命令。接收到命令后，将对其进行处理并将回复发送回客户端。

这是最简单的模型，但是有两个例外：

* KeyDB支持流水线（本文档稍后将介绍）。因此，客户端可以一次发送多个命令，并等待稍后的答复。
* 当KeyDB客户机订阅Pub/Sub通道时，协议会改变语义并成为一个推送协议，即客户机不再需要发送命令，
因为服务器会在收到新消息（对于客户机订阅的通道）后立即自动将其发送给客户机。

除了上述两个例外，KeyDB协议是一个简单的请求-响应协议。

## RESP协议描述

RESP协议在KeyDB 1.2中引入，但它成为KeyDB 2.0中与KeyDB服务器进行通信的标准方式。这是您应该在KeyDB客户机中实现的协议。

RESP实际上是一个序列化协议，支持以下数据类型：简单字符串、错误、整数、大容量字符串和数组。

RESP在KeyDB中用作请求-响应协议的方式如下：

* 客户端将命令作为RESP大容量字符串数组发送到KeyDB服务器。
* 服务器根据命令实现使用RESP类型之一进行响应。

在RESP中，某些数据的类型取决于第一个字节：

* 对于简单字符串，回复的第一个字节是"+"
* 对于错误，回复的第一个字节是"-"
* 对于整数，应答的第一个字节是"："
* 对于大容量字符串，回复的第一个字节是"$"
* 对于数组，应答的第一个字节是"*"

此外，RESP还可以使用稍后指定的大容量字符串或数组的特殊变体来表示空值。
在RESP中，协议的不同部分总是以"\r\n"（CRLF）终止。

## RESP简单字符串

简单字符串的编码方式如下：加号字符，后跟不能包含CR或LF字符的字符串（不允许换行），以CRLF结尾（即"\r\n"）。
简单字符串用于以最小的开销传输非二进制安全字符串。例如，许多KeyDB命令在成功时仅用"OK"回答，即作为RESP简单字符串用以下5个字节编码：

    "+OK\r\n"

为了发送二进制安全字符串，将改用RESP Bulk字符串。

当KeyDB用一个简单的字符串应答时，客户端库应该向调用者返回一个字符串，该字符串由"+"后面的第一个字符组成，直到字符串的末尾，不包括最后的CRLF字节。

## RESP错误

RESP有一个特定的错误数据类型。实际上，错误与RESP简单字符串完全相同，但第一个字符是减号"-"字符，而不是加号。
简单字符串和RESP中的错误之间的真正区别在于，客户机将错误视为异常，而组成错误类型的字符串就是错误消息本身。

    "-Error message\r\n"

错误回复只在发生错误时发送，例如，如果您尝试执行错误数据类型的操作，或者如果命令不存在，等等。
收到错误回复时，库客户端应引发异常。

以下是错误回复的示例：

基本格式为：

    -ERR unknown command 'foobar'
    -WRONGTYPE Operation against a key holding the wrong kind of value

"-"后的第一个字，直到第一个空格或换行符，表示返回的错误类型。这只是KeyDB使用的约定，不是RESP错误格式的一部分。
例如，ERR是泛型错误，而errotype是一个更具体的错误，它意味着客户端试图对错误的数据类型执行操作。
这称为错误前缀，是一种允许客户机理解服务器返回的错误类型的方法，而不依赖给定的、可能会随着时间而改变的确切消息。
客户端实现可以针对不同的错误返回不同类型的异常，或者通过直接将错误名称作为字符串提供给调用者来提供捕获错误的通用方法。
然而，这样的特性不应该被认为是至关重要的，因为它很少有用，有限的客户机实现可能只是返回一个一般的错误条件，例如 false。

## RESP整数

此类型只是一个以CRLF结尾的字符串，表示一个整数，前缀为":"字节。例如"：0\r\n"或"：1000\r\n"是整数应答。
许多KeyDB命令返回RESP整数，如INCR、LLEN和LASTSAVE。
返回的整数没有特殊含义，它只是INCR的增量数，LASTSAVE的UNIX时间等等。但是，返回的整数保证在有符号64位整数的范围内。
整数应答也广泛用于返回true或false。例如，EXISTS或SISMEMBER之类的命令将返回1表示真，返回0表示假。
其他命令，如SADD、SREM和SETNX，如果实际执行了操作，则返回1，否则返回0。
以下命令将以整数答复：SETNX、DEL、EXISTS、INCR、INCRBY、derc、DECRBY、DBSIZE、LASTSAVE、RENAMENX、MOVE、LLEN、SADD、SREM、SISMEMBER、SCARD。

## RESP批量字符串

大容量字符串用于表示长度高达512MB的单个二进制安全字符串。
批量字符串的编码方式如下：
一个"$"字节，后跟组成字符串的字节数（前缀长度），以CRLF结尾。

* 实际字符串数据。
* 最后的CRLF。
* 所以字符串"foobar"的编码如下：

    "$6\r\nfoobar\r\n"

当空字符串只是:

    "$0\r\n\r\n"

还可以使用RESP散列串来使用一个用于表示空值的特殊格式来表示值的不存在。
在这种特殊格式中，长度为-1，并且没有数据，因此空值表示为:

    "$-1\r\n"

这称为**空的大容量字符串。**

当服务器使用空的大容量字符串应答时，客户端库API不应返回空字符串，而应返回nil对象。例如，Ruby库应该返回"nil"，而C库应该返回NULL（或者在reply对象中设置特殊标志），等等。

## RESP数组

客户端使用RESP数组向KeyDB服务器发送命令。类似地，将元素集合返回给客户机use RESP数组的某些KeyDB命令是应答类型。
例如，返回列表元素的LRANGE命令。

RESP数组使用以下格式发送：

一个 * 字符作为第一个字节，后跟数组中的元素数作为十进制数，后跟CRLF。

数组中每个元素的附加RESP类型。

所以空数组如下：

    "*0\r\n"

由两个RESP Bulk字符串"foo"和"bar"组成的数组编码为：

    "*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n"

正如您所看到的，在*>计数> CRLF部分对数组进行预处理之后，组成数组的其他数据类型一个接一个地被连接起来。
例如，一个由三个整数组成的数组编码如下：

    "*3\r\n:1\r\n:2\r\n:3\r\n"

数组可以包含混合类型，元素不必是同一类型。例如，一个由四个整数和一个大容量字符串组成的列表可以编码如下：

    *5\r\n
    :1\r\n
    :2\r\n
    :3\r\n
    :4\r\n
    $6\r\n
    foobar\r\n

（为了清楚起见，reply分为多行）。

服务器发送的第一行是*5\r\n，以便指定后面将有五个答复。然后发送构成多批量应答的项的每个应答。
NULL数组的概念也是存在的，并且是指定空值的另一种方式（通常使用NULL体字符串，但是由于历史原因，我们有两种格式）。
例如，当BLPOP命令超时时，它返回一个计数为-1的空数组，如下例所示：

    "*-1\r\n"

当KeyDB使用空数组应答时，客户端库API应返回空对象而不是空数组。这是区分空列表和不同条件（例如BLPOP命令的超时条件）所必需的。

在RESP中可以使用数组。例如，两个数组的数组编码如下：

    *2\r\n
    *3\r\n
    :1\r\n
    :2\r\n
    :3\r\n
    *2\r\n
    +Foo\r\n
    -Bar\r\n

（为了便于阅读，格式被分成了多行）。

上面的RESP数据类型编码一个两元素数组，该数组包含三个整数1、2、3和一个简单字符串数组以及一个错误。

## 数组中的空元素

数组的单个元素可以为空。这在KeyDB应答中使用，以表示该元素丢失，而不是空字符串。
当指定的键丢失时，与GET pattern选项一起使用SORT命令可能会发生这种情况。包含空元素的数组答复示例：

    *3\r\n
    $3\r\n
    foo\r\n
    $-1\r\n
    $3\r\n
    bar\r\n

第二个元素为空。客户端库应该返回如下内容：

["foo",nil,"bar"]

请注意，这并不是前几节所说的异常，而是进一步指定协议的一个示例。

## 向KeyDB服务器发送命令

现在您已经熟悉了RESP序列化格式，编写KeyDB客户机库的实现将很容易。我们可以进一步指定客户端和服务器之间的交互如何工作：

* 客户机向KeyDB服务器发送一个RESP数组，该数组仅由大容量字符串组成。
* KeyDB服务器对发送任何有效RESP数据类型作为回复的客户端进行回复。

例如，一个典型的交互可以是以下的。
客户机发送命令**LLEN mylist**以获取存储在键mylist中的列表的长度，服务器使用整数回复，如下例所示（C:是客户机，S:服务器）。

    C: *2\r\n
    C: $4\r\n
    C: LLEN\r\n
    C: $6\r\n
    C: mylist\r\n
    
    S: :48293\r\n

通常，为了简单起见，我们用换行符分隔协议的不同部分，但实际的交互是客户端将*2\r\n$4\r\nLLEN\r\n$6\r\nmylist作为一个整体发送。

## 多命令和Pipeling

客户端可以使用相同的连接来发出多个命令。支持Pipeling，因此客户端可以通过一次写入操作发送多个命令，而无需在发出下一个命令之前读取前一个命令的服务器应答。
所有的reply回复都可以在最后阅读。

有关更多信息，请查看我们关于管道的页面。

## 内联命令

有时，您手中只有telnet，需要向KeyDB服务器发送命令。尽管KeyDB协议实现起来很简单，但在交互式会话中使用它并不理想，keydb-cli可能并不总是可用的。
为此，KeyDB还以一种为人类设计的特殊方式接受命令，称为内联命令格式。

下面是使用内联命令的服务器/客户端聊天的示例（服务器聊天以S开头，客户端聊天以C开头）

    C: PING
    S: +PONG

下面是内联命令返回整数的另一个示例：

    C: EXISTS somekey
    S: :0

基本上，您只需在telnet会话中编写空格分隔的参数。由于统一请求协议中没有以*开头的命令，KeyDB能够检测到这种情况并分析您的命令。

## KeyDB协议的高性能解析器

虽然KeyDB协议是非常容易理解和实现的，但它可以以类似于二进制协议的性能来实现。
RESP使用前缀长度来传输大容量数据，因此不需要像使用JSON那样扫描负载中的特殊字符，也不需要引用需要发送到服务器的负载。
批量长度和多批量长度可以使用代码进行处理，该代码对每个字符执行单个操作，同时扫描CR字符，如以下C代码：

    #include <stdio.h>
    
    int main(void) {
        unsigned char *p = "$123\r\n";
        int len = 0;
    
        p++;
        while(*p != '\r') {
            len = (len*10)+(*p - '0');
            p++;
        }
    
        /* Now p points at '\r', and the len is in bulk_len. */
        printf("%d\n", len);
        return 0;
    }

在识别出第一个CR之后，它可以与下面的LF一起跳过，而无需任何处理。然后，可以使用不以任何方式检查有效负载的单个读取操作来读取大容量数据。
最后，剩余的CR和LF字符将被丢弃，而不进行任何处理。

虽然KeyDB协议在性能上与二进制协议相当，但在大多数非常高级的语言中实现起来要简单得多，从而减少了客户端软件中的错误数量。
