# FAQ

## KeyDB与Redis有何不同？

KeyDB最初是Redis的一个分支，在那里我们的基本信仰不同。
我们认为Redis应该是多线程的，Redis的核心开发团队并不打算支持它。叉子一开始是为了加速我们和其他用户感兴趣的领域的发展。
在对Redis进行多线程处理并看到其优点和性能提升之后，我们觉得拥有目前只在一些专有模块中支持的特性的开源实现是有价值的。使用Redis的一些方面引入了许多不必要的复杂性，例如分片和高可用性设置。
因此，KeyDB引入了一些特性，如活动复制和多主配置选项。其他特性，如flash支持、aws s3备份，也是我们认为应该成为每个实例的基本代码和标准的一部分的重要特性。

KeyDB也主要是用c++编写的，允许这个项目加速到不同的级别。其他备受追捧的afer功能的添加计划仍在继续，KeyDB将在发布这些功能时予以公布。
KeyDB在性能方面处于领先地位，您可以预期KeyDB产品将在可用时进行调整并利用最新的硬件和软件。

## 为什么KeyDB与大多数其他键值存储不同？

主要有两个原因。

    * KeyDB是 key-value DBs中的另一种演化路径，其中的值可以包含更复杂的数据类型，并在这些数据类型上定义原子操作。
      KeyDB数据类型与基本数据结构密切相关，因此向程序员公开，而不需要额外的抽象层。
    * KeyDB是一个内存中但持久的磁盘数据库，因此它代表了一种不同的权衡，在这种权衡中，可以获得非常高的写入和读取速度，但数据集不能大于内存。
      内存数据库的另一个优点是，与磁盘上的相同数据结构相比，复杂数据结构的内存表示要简单得多，因此KeyDB可以做很多事情，但内部复杂度很低。
      同时，这两种磁盘存储格式（RDB和AOF）不需要适合随机访问，因此它们很紧凑，并且总是以仅附加的方式生成（甚至AOF日志旋转也是仅附加的操作，因为新版本是从内存中的数据副本生成的）。
      然而，与传统的磁盘存储相比，这种设计还涉及不同的挑战。作为内存中的主要数据表示形式，KeyDB操作必须小心处理，以确保磁盘上的数据集始终有更新版本。

## KeyDB内存占用量是多少？

举几个例子（都是使用64位实例获得的）:

    * 空实例使用~3MB内存。
    * 一百万个小键->字符串-值对使用 大约85MB的内存。
    * 一百万个键->散列值，表示一个有5个字段的对象，使用大约160MB的内存

使用 keydb-benchmark 实用程序生成随机数据集并使用INFO memory命令检查所使用的空间来测试用例是很简单的。
 
64位系统将比32位系统使用更多的内存来存储相同的key，特别是在key和value较小的情况下。
这是因为指针在64位系统中占用8个字节。当然，它的优点是在64位系统中可以有很多内存，因此为了运行大型KeyDB服务器，或多或少需要64位系统。另一种选择是分片。 
 
## 我喜欢KeyDB的高级操作和特性，但我不喜欢它占用内存中的所有内容，而且我不能让数据集的内存更大。打算改变这个吗？

"KeyDB on flash"是一种解决方案，它能够为更大的数据集使用混合RAM/flash方法。
DRAM的每GB成本明显高于闪存等非易失性存储器。启用时，KeyDB可以将访问频率较低的数据存储在非易失性存储器中，而不是RAM中。
必要时，KeyDB会主动地将数据从非易失性存储器中调出或调出。当然，您也可以使用普通旋转磁盘，但不建议使用，因为性能会很差。
KeyDB希望底层设备具有良好的随机I/O性能。

闪存仅用于临时数据，其性能与RAM类似。坚持仍然是通过正常的机制来实现的。当使用"free"命令查看内存时，KeyDB使用的内存将显示为"buff/cache"。
KeyDB依赖于内核的分页策略来决定将什么放在磁盘上。

## 将KeyDB与磁盘数据库一起使用是一个好主意吗？

是的，一种常见的设计模式包括在KeyDB中使用非常重的小数据（以及需要KeyDB数据结构以有效方式对问题建模的数据），将大数据块放入SQL或最终在磁盘上保持一致。
类似地，有时使用KeyDB以便在内存中获取存储在磁盘数据库中的相同数据子集的另一个副本。这看起来类似于缓存，但实际上是一个更高级的模型，因为通常KeyDB数据集与磁盘上的DB数据集一起更新，而不是在缓存未命中时刷新。

## 有什么可以降低KeyDB内存使用率的吗？
 
如果可以，请使用KeyDB 32位实例。还可以很好地使用小哈希、列表、排序集和整数集，因为KeyDB能够以更紧凑的方式在少数元素的特殊情况下表示这些数据类型。内存优化页中有更多信息。
 
## 如果KeyDB内存不足，会发生什么情况？

KeyDB要么被Linux内核OOM杀手杀死，要么出错崩溃，要么开始减速。在现代操作系统中，malloc() 返回NULL并不常见，通常服务器会开始交换（如果配置了一些交换空间），KeyDB性能也会开始下降，因此您可能会注意到有问题。

KeyDB具有内置保护，允许用户设置内存使用的最大限制，使用配置文件中的maxmemory选项设置KeyDB可以使用的内存限制。如果达到此限制，KeyDB将开始回复写入命令的错误（但将继续接受只读命令），或者在使用KeyDB进行缓存的情况下，可以将其配置为在达到最大内存限制时收回密钥。

我们有详细的文档，以防您计划使用KeyDB作为LRU缓存。

INFO命令将报告KeyDB正在使用的内存量，这样您就可以编写脚本来监视KeyDB服务器在到达之前是否检查了关键条件。

## 在Linux下，即使我有很多空闲RAM，后台保存也会失败，出现fork()错误！

简短回答：echo 1 > /proc/sys/vm/overcommit_memory:）

现在长的：

KeyDB后台保存模式依赖于现代操作系统中fork的copy-on-write语义：KeyDB forks（创建子进程）是父进程的精确副本。子进程将DB转储到磁盘上并最终退出。
理论上，子进程应该使用与父进程相同的内存作为副本，但实际上，由于大多数现代操作系统实现了写时拷贝语义，父进程和子进程将共享公共内存页。
只有在子页或父页中更改时，才会复制页。因为理论上，当子进程正在保存时，所有的页面都可能发生变化，所以Linux不能预先告诉子进程将占用多少内存，所以如果overcommit_memory设置为零，fork将失败，除非有足够的空闲RAM来复制所有父内存页面，结果是如果您有一个KeyDB数据集只有3GB和2GB的可用内存，它将失败。

将overcommit_memory设置为1会告诉Linux以更乐观的分配方式放松并执行fork，这确实是KeyDB所需要的。

了解Linux虚拟内存如何工作以及其他overcommit_memory和overcommit_ratio的替代方案的一个很好的来源是红帽杂志《理解虚拟内存》的这篇经典文章。
注意，本文有1个和2个overcommit_memory reversed配置值：请参阅proc(5)手册页以了解可用值的正确含义。

## KeyDB磁盘快照是原子的吗？
 
是的，当服务器不在执行命令的范围内时，KeyDB后台保存进程总是分叉的，因此从磁盘快照的角度来看，RAM中报告为原子的每个命令也是原子的。
 
## 单个KeyDB实例可以保存的最大键数是多少？散列、列表、集合、排序集合中元素的最大数目是多少？

KeyDB最多可以处理2^32个key，并且在实践中测试为每个实例至少处理2.5亿个key。

每个hash、list、set和sorted set都可以容纳2^32个元素。

换句话说，您的限制可能是系统中的可用内存。

## 我的slave声称和它的master相比key的数量不同，为什么？

如果使用生存时间有限的key（KeyDB expires），则这是正常行为。这就是发生的情况：

    * 主服务器在与从服务器的第一次同步时生成一个RDB文件。
    * RDB文件将不包括主文件中已过期的key，但这些key仍在内存中。
    * 然而，这些key仍然在KeyDB主机的内存中，即使逻辑上已过期。它们不会被认为是存在的，但是内存将在以后被逐步回收，无论是增量的还是显式的访问。
    然而，虽然这些键不是数据集的逻辑部分，但它们在信息输出和DBSIZE命令中被公布。
    * 当从机读取主机生成的RDB文件时，不会加载这组key。

因此，对于拥有多个expire设置的key的用户来说，由于这个工件，在从机中看到的key较少是很常见的，但是在实例内容中没有实际的逻辑差异。
