# KeyDB的二级索引

KeyDB并不完全是键值存储，因为值可以是复杂的数据结构。
但是它有一个外部键值shell：在API级别，数据由键名寻址。
可以说，KeyDB本身只提供主键访问。然而，由于KeyDB是一个数据结构服务器，它的功能可用于索引，
以便创建不同类型的二级索引，包括复合（多列）索引。

本文档解释了如何使用以下数据结构在KeyDB中创建索引：

    * 按ID或其他数字字段创建辅助索引的排序集。
    * 用于创建更高级的次级索引、复合索引和图遍历索引的具有可排序范围的排序集。
    * 用于创建随机索引的集合。
    * 用于创建简单可iterable索引和最后N个项索引的列表。

使用KeyDB实现和维护索引是一个高级主题，因此需要对数据执行复杂查询的大多数用户应该了解关系存储是否能更好地为他们提供服务。

然而，通常情况下，特别是在缓存场景中，有明确的需要将索引数据存储到KeyDB中，以便加速需要执行某种形式的索引的公共查询。

## 具有排序集的简单数值索引

使用KeyDB可以创建的最简单的二级索引是使用排序集数据类型，该数据类型是一个数据结构，表示一组按浮点数排序的元素，浮点数是每个元素的分数。
元素按从最小到最高的顺序排列。

由于记分是双精度浮点，所以可以用香草排序的集合建立的索引仅限于索引字段是给定范围内的数字。

构建此类索引的两个命令是ZADD和ZRANGEBYSCORE，用于分别添加指定范围内的项和检索指定范围内的项。

例如，通过向排序集添加元素，可以按年龄为一组人名编制索引。元素是人的名字，分数是年龄。

    ZADD myindex 25 Manuel
    ZADD myindex 18 Anna
    ZADD myindex 35 Jon
    ZADD myindex 67 Helen

为了检索年龄在20到40岁之间的所有人员，可以使用以下命令：

    ZRANGEBYSCORE myindex 20 40
    1) "Manuel"
    2) "Jon"

通过使用ZRANGEBYSCORE的WITHSCORES选项，还可以获得与返回元素相关的分数。

ZCOUNT命令可用于检索给定范围内的元素数，而不实际获取元素，这也很有用，
特别是考虑到无论范围大小，操作都是在对数时间内执行的。

范围可以是包含的或独占的，有关详细信息，请参阅ZRANGEBYSCORE命令文档。

**注意：** 使用ZREVRANGEBYSCORE可以按相反的顺序查询一个范围，当数据按给定的方向（升序或降序）编制索引时，
这通常很有用，但我们希望以相反的方式检索信息。

### 使用对象id作为关联值

在上面的例子中，我们把名字和年龄联系起来。但是，一般来说，我们可能希望索引存储在其他位置的对象的某个字段。与直接使用排序集值存储与索引字段相关联的数据不同，只存储对象的ID是可能的。

例如，我可能有代表用户的KeyDB散列。每个用户都由一个key表示，可通过ID直接访问：

	HMSET user:1 id 1 username john ctime 1444809424 age 38
	HMSET user:2 id 2 username maria ctime 1444808132 age 42
	HMSET user:3 id 3 username jballard ctime 1443246218 age 33

如果要创建索引以便按用户年龄查询用户，可以执行以下操作：

	ZADD user.age.index 38 1
	ZADD user.age.index 42 2
	ZADD user.age.index 33 3

这次，与排序集中的分数关联的值是对象的ID。因此，一旦我使用ZRANGEBYSCORE查询索引，我还必须使用HGETALL或类似命令检索所需的信息。
明显的优点是，只要不更改索引字段，对象就可以在不接触索引的情况下更改。

在下一个示例中，我们几乎总是使用id作为与索引相关联的值，因为这通常是更为合理的设计，只有少数例外。

## 更新简单排序集索引

我们常常把随时间变化的事物编入索引。在上面的例子中，用户的年龄每年都在变化。在这种情况下，使用出生日期而不是年龄本身作为索引是有意义的，但是在其他情况下，我们简单地希望某个字段不时更改，并且索引反映这种更改。

ZADD命令使更新简单索引成为一个非常简单的操作，因为用不同的分数和相同的值重新添加一个元素只需更新分数并将元素移动到正确的位置，所以如果用户john年满39岁，为了更新代表用户的散列和索引中的数据，我们需要执行以下两个命令：

	HSET user:1 age 39
	ZADD user.age.index 39 1

该操作可以包装在 MULTI / EXEC 事务中，以确保两个字段都已更新或没有更新。

### 将多维数据转换为线性数据

使用排序集创建的索引只能索引单个数值。因此，您可能认为不可能使用此类索引为具有多个维度的内容编制索引，
但实际上这并不总是正确的。如果可以高效地以线性的方式表示多维的内容，那么通常可以使用简单的排序集进行索引。

例如，KEYDB地理索引API使用一个排序的集合使用一个称为地理哈希的技术通过纬度和经度来索引位置。
排序集得分表示经纬度的交替位，因此我们将排序集的线性得分映射到地球表面的许多小正方形。
通过执行8+1样式的中心加邻域搜索，可以按半径检索元素。

### 分数限制

排序集合元素得分是双精度整数。这意味着它们可以用不同的错误表示不同的十进制或整数值，因为它们在内部使用指数表示。
然而，有趣的是，索引的目的是始终能够表示没有任何错误号码之间的-9007199254740992和9007199254740992，这是 -/+ 2^53。

当表示更大的数字时，需要一种不同的索引形式，能够以任何精度索引数字，称为词典式索引。

## 词典式的索引

KeyDB排序集有一个有趣的属性。当元素以相同的分数添加时，它们按字典方式排序，将字符串作为二进制数据与memcmp() 函数进行比较。

对于不知道C语言或memcmp函数的人来说，这意味着具有相同分数的元素将被排序，比较它们字节的原始值，逐字节排序。
如果第一个字节相同，则检查第二个字节，以此类推。
如果两个字符串的公共前缀相同，则较长的字符串被视为二者中的较大者，因此"foobar"大于"foo"。

有ZrangeBeLeX和ZLyCube这样的命令，它们能够以字典的方式查询和计数范围，假设它们与排序的集合一起使用，其中所有元素都具有相同的分数。

这个KeyDB特性基本上相当于一个b树数据结构，该结构通常用于用传统数据库实现索引。
如您所料，正因为如此，才有可能使用这个KeyDB数据结构来实现非常奇特的索引。

在深入研究词典编纂索引之前，让我们看看排序集是如何在这个特殊的操作模式下运行的。
因为我们需要添加具有相同分数的元素，所以我们将始终使用特殊分数0。

	ZADD myindex 0 baaa
	ZADD myindex 0 abbb
	ZADD myindex 0 aaaa
	ZADD myindex 0 bbbb

从排序后的集合中获取所有元素都会立即显示它们是按字典顺序排列的。

	ZRANGE myindex 0 -1
	1) "aaaa"
	2) "abbb"
	3) "baaa"
	4) "bbbb"

现在我们可以使用ZRANGEBYLEX来执行范围查询。

	ZRANGEBYLEX myindex [a (b
	1) "aaaa"
	2) "abbb"

注意，在范围查询中，我们在min和max元素前面加上了特殊字符[和（。
此前缀是必需的，它们指定范围中的元素是包含的还是独占的。
所以范围[a（b）意味着在包容和B排他性之间对所有元素进行词典编纂，这是从A开始的所有元素。

还有两个特殊字符表示无限负字符串和无限正字符串，分别是 - 和 +。

	ZRANGEBYLEX myindex [b +
	1) "baaa"
	2) "bbbb"

基本上就是这样。让我们看看如何使用这些特性来构建索引。

### 第一个例子：完成

索引的一个有趣的应用是完成。完成是当您开始在搜索引擎中键入查询时发生的事情：
用户界面将预测您可能键入的内容，提供以相同字符开头的常见查询。

一种简单的完成方法是将从用户获得的每个查询添加到索引中。
例如，如果用户搜索香蕉，我们只需执行以下操作：

    ZADD myindex 0 banana

对于遇到的每个搜索查询，依次类推。然后，当我们想完成用户输入时，我们使用ZRANGEBYLEX执行一个范围查询。
假设用户在搜索表单中键入"bit"，我们希望提供从"bit"开始的可能搜索关键字。
我们向KeyDB发送这样的命令：

	ZRANGEBYLEX myindex "[bit" "[bit\xff"

基本上，我们使用用户现在键入的字符串作为开始来创建一个范围，同一个字符串加上一个设置为255的尾随字节（在本例中为xff）作为范围的结束。
这样我们就可以得到用户正在键入的字符串的所有开头字符串。

请注意，我们不希望返回太多项，因此可以使用LIMIT选项来减少结果数。

### 加入频率

上面的方法有点幼稚，因为所有的用户搜索都是相同的。
在实际系统中，我们希望根据字符串的频率完成字符串：
与很少键入的搜索字符串相比，非常流行的搜索将以更高的概率被提出。

为了实现一些依赖于频率的东西，同时自动适应未来的输入，
通过清除不再流行的搜索，我们可以使用一个非常简单的流算法。

首先，我们修改索引，以便不仅存储搜索项，而且存储与搜索项关联的频率。
因此，我们不只是添加banana，而是添加banana:1，其中1是频率。

	ZADD myindex 0 banana:1

我们还需要逻辑来增加索引，如果索引中已经存在搜索项，那么我们实际上要做的是这样的事情：

	ZRANGEBYLEX myindex "[banana:" + LIMIT 1 1
	1) "banana:1"

这将返回banana的单个条目，如果它存在的话。然后我们可以增加相关的频率并发送以下两个命令：

	ZREM myindex 0 banana:1
	ZADD myindex 0 banana:2

请注意，由于可能存在并发更新，因此应通过Lua脚本发送上述三个命令，
以便Lua脚本原子地获取旧计数，并使用递增的分数重新添加项。

结果就是，每次用户搜索banana时，我们都会更新我们的条目。

还有更多：我们的目标是让项目搜索非常频繁。所以我们需要某种形式的净化。
当我们实际查询索引以完成用户输入时，可能会看到类似的情况：

	ZRANGEBYLEX myindex "[banana:" + LIMIT 1 10
	1) "banana:123"
	2) "banahhh:1"
	3) "banned user:49"
	4) "banning:89"

例如，显然没有人搜索"banahh"，但是查询只执行了一次，所以我们最终将它呈现给用户。

这就是我们能做的。从返回的项目中，我们随机选择一个，将其分数递减一，然后将其与新分数相加。
但是，如果分数达到0，我们只需从列表中删除该项。您可以使用更高级的系统，但从长远来看，索引将包含顶部搜索，
如果顶部搜索将随着时间的推移而改变，它将自动适应。

此算法的一个改进是根据权重在列表中选择条目：分数越高，则越不可能选择条目以减少其分数，或将其逐出

### 规范化大小写和重音的字符串

在完成示例中，我们总是使用小写字符串。然而，事实比这复杂得多：语言有大写的名称、重音等等。

处理这个问题的一个简单方法是实际规范化用户搜索的字符串。无论用户搜索"Banana"、"BANANA"或"Ba'nana"，我们都可能把它变成"banana"。

然而，有时我们可能会向用户呈现原始类型的类型，即使我们规范了索引的字符串。
为了做到这一点，我们要做的是更改索引的格式，这样就不只是存储term:frequency，而是存储normalized:frequency:original，如下例所示：

    ZADD myindex 0 banana:273:Banana

基本上，我们添加了另一个字段，我们将提取并仅用于可视化。
范围将始终使用规范化字符串来计算。这是一个有多个应用程序的常见技巧。

### 在索引中添加辅助信息

当以直接方式使用排序集时，每个对象都有两个不同的属性：作为索引的分数和关联的值。
当使用词典索引代替时，分数总是设置为0，基本上根本不使用。我们只剩下一个字符串，这就是元素本身。

与前面的完成示例一样，我们仍然能够使用分隔符存储关联的数据。
例如，我们使用冒号来添加完成的频率和原始单词。

一般来说，我们可以向我们的索引键添加任何相关的值。
为了使用字典索引来实现一个简单的键值存储，我们只需将条目存储为键：

    ZADD myindex 0 mykey:myvalue

并使用以下命令搜索key：

	ZRANGEBYLEX myindex mykey: + LIMIT 1 1
	1) "mykey:myvalue"

然后提取冒号后面的部分以检索值。然而，在这种情况下要解决的问题是碰撞。
冒号字符可能是键本身的一部分，因此必须选择它，以免与添加的键冲突。

由于KeyDB中的字典范围是二进制安全的，所以可以使用任何字节或任何字节序列。
但是，如果接收到不受信任的用户输入，最好使用某种形式的转义，以确保分隔符永远不会碰巧成为key的一部分。

例如，如果使用两个空字节作为分隔符"\0\0"，则可能需要始终将空字节转义为字符串中的两个字节序列。

### 数字填充

只有当手头的问题是索引字符串时，词典索引看起来才是好的。
实际上，使用这种索引来执行任意精度数字的索引是非常简单的。

在ASCII字符集中，数字以0到9的顺序出现，所以如果我们在数字前加上前导零，
结果是，将它们作为字符串进行比较将按其数值排序。

	ZADD myindex 0 00324823481:foo
	ZADD myindex 0 12838349234:bar
	ZADD myindex 0 00000000111:zap

	ZRANGE myindex 0 -1
	1) "00000000111:zap"
	2) "00324823481:foo"
	3) "12838349234:bar"

我们有效地创建了一个索引，使用的数值字段可以是我们想要的那么大。
也适用于任何精度的浮点数，方法是确保我们在数字部分前加零，在小数部分后加零，如下数字列表所示：

    01000000000000.11000000000000
    01000000000000.02200000000000
    00000002121241.34893482930000
    00999999999999.00000000000000
   
### 使用二进制形式的数字

以十进制存储数字可能会占用太多内存。另一种方法是直接以二进制形式存储数字，例如128位整数。
但是，要使其工作，您需要以大端格式存储数字，以便将最重要的字节存储在最不重要的字节之前。
这样，当KeyDB将字符串与memcmp()进行比较时，它将有效地按数值对数字进行排序。

请记住，以二进制格式存储的数据在调试时不易观察，更难解析和导出。所以这绝对是一种交换。

## 组合索引

到目前为止，我们探索了索引单个字段的方法。但是，我们都知道SQL存储能够使用多个字段创建索引。
例如，我可以按房间号和价格为一家非常大的商店的产品编制索引。

我需要运行查询以检索给定房间中具有给定价格范围的所有产品。我能做的是按以下方式为每个产品编制索引：

	ZADD myindex 0 0056:0028.44:90
	ZADD myindex 0 0034:0011.00:832

这里的字段是room:price:product_id。为了简单起见，我在示例中只使用了四位数字填充。
辅助数据（产品ID）不需要任何填充。

有了这样的指数，要得到56号房所有价格在10美元到30美元之间的产品是非常容易的。我们可以运行以下命令：

	ZRANGEBYLEX myindex [0056:0010.00 [0056:0030.00

以上称为组合索引。它的有效性取决于字段的顺序和我要运行的查询。
例如，不能有效地使用上述指数，以获得具有特定价格范围的所有产品，而不管房间号如何。
但是我可以使用主键来运行查询，不管价格如何，比如给我44房间的所有产品。

复合索引功能非常强大，用于传统存储以优化复杂查询。在KeyDB中，它们既可以用于实现存储在传统数据存储中的东西的非常快速的内存KeyDB索引，
也可以用于直接索引KeyDB数据。

# 更新词典索引

在词典编纂索引中，索引的值可以变得非常奇特，并且很难或缓慢地从我们存储的对象中重建。
因此，在使用更多内存的代价下，简化索引处理的一种方法是，在表示索引的已排序集的旁边加入一个散列，
将对象ID映射到当前索引值。

因此，例如，当我们索引时，我们还将添加到哈希：

	MULTI
	ZADD myindex 0 0056:0028.44:90
	HSET index.content 90 0056:0028.44:90
	EXEC

这并不总是必要的，但可以简化更新索引的操作。
为了删除我们为对象ID 90编制索引的旧信息，不管对象的当前字段值如何，
我们只需按对象ID检索散列值，并在sorted set视图中对其进行ZREM。

# 使用hexastore表示和查询图形

复合索引有一个很酷的地方，那就是它们可以方便地用一种叫做Hexastore的数据结构来表示图。

hexastore为对象之间的关系提供了表示，这些关系由主语、谓语和对象构成。对象之间的简单关系可以是：

	john is-friend-of matteocollina

为了表示这种关系，我可以在词典编纂索引中存储以下元素：

	ZADD myindex 0 spo:john:is-friend-of:matteocollina

注意，我在我的项目前面加了字符串spo。这意味着该项表示一个主语、谓语、宾语关系。

In可以为同一关系再添加5个条目，但顺序不同：

	ZADD myindex 0 sop:john:matteocollina:is-friend-of
	ZADD myindex 0 ops:matteocollina:is-friend-of:john
	ZADD myindex 0 osp:matteocollina:john:is-friend-of
	ZADD myindex 0 pso:is-friend-of:john:matteocollina
	ZADD myindex 0 pos:is-friend-of:matteocollina:john

现在事情开始变得有趣了，我可以用很多不同的方式查询这个图。例如，约翰的朋友都是谁？

	ZRANGEBYLEX myindex "[spo:john:is-friend-of:" "[spo:john:is-friend-of:\xff"
	1) "spo:john:is-friend-of:matteocollina"
	2) "spo:john:is-friend-of:wonderwoman"
	3) "spo:john:is-friend-of:spiderman"

或者，john 和 matteocollina有什么关系，第一个是主题，第二个是对象？

	ZRANGEBYLEX myindex "[sop:john:matteocollina:" "[sop:john:matteocollina:\xff"
	1) "sop:john:matteocollina:is-friend-of"
	2) "sop:john:matteocollina:was-at-conference-with"
	3) "sop:john:matteocollina:talked-with"

通过组合不同的问题，我可以问一些有趣的问题。例如：我所有的朋友都是谁，像啤酒一样，住在巴塞罗那，而美泰科利纳也认为是朋友？
为了得到这些信息，我先从一个spo查询开始，查找我的所有朋友。然后对得到的每个结果执行spo查询，
检查它们是否喜欢啤酒，删除那些我找不到这种关系的啤酒。我再这样做是为了按城市过滤。
最后，我执行一个ops查询来查找我获得的列表，matteocellina认为他是我的朋友。

为了更好地理解这些想法，请务必查看Matteo Collina关于Levelgraph的幻灯片。

# 多维索引

更复杂的索引类型是一种索引，它允许您在同时查询两个或多个变量的特定范围时执行查询。
例如，我可能有一个代表年龄和薪水的数据集，我想检索50到55岁之间薪水在70000到85000之间的所有人。

这个查询可以用多列索引执行，但这需要我们选择第一个变量，然后扫描第二个变量，这意味着我们可能做的工作比需要的多得多。
可以使用不同的数据结构执行涉及多个变量的此类查询。例如，有时使用多维树，如k-d树或r树。在这里，我们将介绍一种不同的方法来索引数据到多个维度，
使用表示技巧，使我们能够以非常有效的方式使用KEDB词典编纂范围来执行查询。

让我们从想象问题开始。在这张图片中，我们在空间中有点，代表我们的数据样本，其中x和y是我们的坐标。两个变量的最大值都是400。

图片中的蓝色框表示我们的查询。我们想要x在50到100之间，y在100到300之间的所有点。

空间中的点

为了表示使这类查询快速执行的数据，我们首先用0填充数字。例如，假设我们想把点10，25（x，y）加到索引中。
假设例子中的最大范围是400，我们可以垫到三个数字，所以我们得到：

    x = 010
    y = 025

现在我们要做的是交错数字，取x中最左边的数字，y中最左边的数字，以此类推，以便创建一个数字：

	001205

这是我们的索引，但是为了更容易地重建原始表示，如果我们需要（以空间为代价），我们还可以将原始值作为附加列添加：

	001205:10:25

现在，让我们来解释一下这个表示，以及为什么它在范围查询上下文中很有用。
例如，让我们取蓝色框的中心，它位于x=75和y=200。我们可以像前面那样通过交错数字对该数字进行编码，获得：

	027050

如果我们分别用00和99替换最后两个数字会怎么样？我们得到了一个词汇连续的范围：

	027000至027099

它映射到一个正方形，表示x变量在70到79之间，y变量在200到209之间的所有值。我们可以在此间隔内写入随机点，以便识别此特定区域：

小面积

因此，上面的词典查询允许我们轻松地查询图片中特定的方块中的点。但是对于我们正在搜索的框来说，正方形可能太小，因此需要太多查询。因此，我们也可以这样做，但不是用00和99替换最后两个数字，而是用最后四个数字，得到以下范围：

	020000 029999

这一次，范围表示x在0到99之间，y在200到299之间的所有点。在这段时间内随机绘制点，显示了这个更大的区域：

大面积

哎呀，现在我们的搜索区域太大了，我们的搜索框还没有完全包含进去。我们需要更多的粒度，但是我们可以通过以二进制形式表示我们的数字来轻松获得它。
这一次，当我们替换数字而不是得到十倍大的正方形时，我们得到的正方形只有两倍大。

我们的二进制数字，假设每个变量只需要9位（以表示数值高达400的数字），将是：

	x=75->001001011
	y=200->011001000

因此，通过交错数字，我们在索引中的表示是：

	00011000011001010:75:200

让我们看看当我们替换最后的2，4，6，8时我们的射程是多少。。。交织表示中0和1的位：

	2 bits: x between 70 and 75, y between 200 and 201 (range=2)
	4 bits: x between 72 and 75, y between 200 and 203 (range=4)
	6 bits: x between 72 and 79, y between 200 and 207 (range=8)
	8 bits: x between 64 and 79, y between 192 and 207 (range=16)

等等。现在我们有了更好的粒度！如您所见，从索引中替换N位会给我们提供2^(N/2) 边的搜索框。

所以我们要做的是检查我们搜索框较小的维度，并检查这个数字的二次方最近的一次方。
我们的搜索框是50100到100300，所以它的宽度是50，高度是200。我们取二者中较小的一个，50，并检查二者的最近幂，即64。
64是2^6，因此我们将使用从交织表示中替换最新12位的索引（这样我们结束时只替换每个变量的6位）。

然而，单个正方形可能无法覆盖我们的所有搜索，因此我们可能需要更多。我们要做的是从搜索框的左下角（50100）开始，
用0替换每个数字的最后6位，找到第一个范围。然后我们在右上角做同样的动作。

有了两个简单的嵌套for循环，我们只增加有效位，就可以找到这两个循环之间的所有平方。
对于每个正方形，我们将两个数字转换成交织表示，并使用转换后的表示作为开始创建范围，使用相同的表示，但最新的12位作为结束范围。

对于找到的每个方块，我们执行查询并将元素放入其中，删除搜索框之外的元素。

把它转换成代码很简单。下面是一个Ruby示例:

    def spacequery(x0,y0,x1,y1,exp)
        bits=exp*2
        x_start = x0/(2**exp)
        x_end = x1/(2**exp)
        y_start = y0/(2**exp)
        y_end = y1/(2**exp)
        (x_start..x_end).each{|x|
            (y_start..y_end).each{|y|
                x_range_start = x*(2**exp)
                x_range_end = x_range_start | ((2**exp)-1)
                y_range_start = y*(2**exp)
                y_range_end = y_range_start | ((2**exp)-1)
                puts "#{x},#{y} x from #{x_range_start} to #{x_range_end}, y from #{y_range_start} to #{y_range_end}"
    
                # Turn it into interleaved form for ZRANGEBYLEX query.
                # We assume we need 9 bits for each integer, so the final
                # interleaved representation will be 18 bits.
                xbin = x_range_start.to_s(2).rjust(9,'0')
                ybin = y_range_start.to_s(2).rjust(9,'0')
                s = xbin.split("").zip(ybin.split("")).flatten.compact.join("")
                # Now that we have the start of the range, calculate the end
                # by replacing the specified number of bits from 0 to 1.
                e = s[0..-(bits+1)]+("1"*bits)
                puts "ZRANGEBYLEX myindex [#{s} [#{e}"
            }
        }
    end
    
    spacequery(50,100,100,300,6)

这是一个非常有用的索引策略，将来可以以本地方式在KeyDB实现。
现在，好的是，复杂性可以很容易地封装在一个库中，可以用来执行索引和查询。

# 带负数或浮点数的多维索引

表示负值的最简单方法是使用无符号整数并使用偏移量表示它们，这样，
在对索引表示中的数字进行转换之前，索引时可以添加较小负整数的绝对值。

对于浮点数，最简单的方法可能是将它们转换为整数，
方法是将整数乘以与要保留的点后面的位数成比例的10的幂。

# 非范围索引

到目前为止，我们检查了按范围或按单个项查询的索引。但是，可以使用其他KeyDB数据结构（如集合或列表）来构建其他类型的索引。
它们是非常常用的，但也许我们并不总是意识到它们实际上是索引的一种形式。

例如，我可以将对象id索引到Set数据类型中，以便通过SRANDMEMBER使用get random elements操作来检索一组随机对象。
当我需要的是测试一个给定的项目是否存在或者有一个布尔属性时，SET也可以用来检查是否存在。

同样，可以使用列表将项目索引为固定顺序。我可以将所有项添加到KeyDB列表中，并使用与源和目标相同的密钥名使用RPOPLPUSH旋转列表。
当我想以相同的顺序一次又一次地处理一组给定的项时，这很有用。考虑一个RSS提要系统，它需要定期刷新本地副本。

KeyDB经常使用的另一个流行的索引是capped list，其中的项使用LPUSH添加，并使用LTRIM修剪，以便创建一个视图，
其中只包含遇到的最新N个项，其顺序与看到的顺序相同。

# 索引不一致

保持索引更新可能是一项挑战，在数月或数年的时间里，
可能会因为软件错误、网络分区或其他事件而添加不一致。

可以使用不同的策略。如果索引数据不在KeyDB read repair的范围内，则可以采用一种解决方案，
即在请求数据时以一种延迟的方式修复数据。当我们索引存储在KeyDB本身中的数据时，
可以使用SCAN系列命令来从头开始增量地验证、更新或重建索引。

