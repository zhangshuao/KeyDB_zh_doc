# 流简介

流是KeyDB 5.0引入的一种新的数据类型，它以更抽象的方式对日志数据结构建模，
但是日志的本质仍然是完整的：KeyDB流与日志文件一样，通常实现为以仅附加模式打开的文件，主要是一种仅附加的数据结构。
至少在概念上，因为KeyDB流是内存中表示的抽象数据类型，所以它们实现了更强大的操作，以克服日志文件本身的限制。

使KeyDB流成为KeyDB中最复杂的类型的原因是，尽管数据结构本身非常简单，但它实现了附加的、非强制性的特性：
一组阻塞操作允许消费者等待生产者添加到流中的新数据，此外还有一个称为消费者组的概念。

消费者群体最初是由流行的消息传递系统Kafka（TM）引入的。
KeyDB以完全不同的术语重新实现了一个类似的想法，但目标是相同的：允许一组客户机使用同一消息流的不同部分进行协作。

## 流基础知识

为了了解KeyDB流是什么以及如何使用它们，我们将忽略所有高级功能，而将重点放在数据结构本身，即用于操作和访问它的命令。
这基本上是大多数其他KeyDB数据类型（如列表、集合、排序集合等）所共有的部分。
但是，请注意，列表还有一个可选的更复杂的阻塞API，由BLPOP等命令导出。
所以流与列表在这方面没有太大的区别，只是附加的API更复杂、更强大。

因为流是一个只追加的数据结构，所以名为XADD的基本写命令将一个新条目追加到指定的流中。
流条目不只是一个字符串，而是由一个或多个字段值对组成。
这样，流的每个条目都是结构化的，就像一个以CSV格式编写的只追加的文件，其中每行中都有多个分隔的字段。

    > XADD mystream * sensor-id 1234 temperature 19.8
    1518951480106-0

上面对XADD命令的调用使用自动生成的条目id将条目传感器id:123、temperature:19.8添加到key mystream的流中，该条目id是命令返回的条目id，具体是1518951480106-0。
它将key名mystream作为第一个参数，第二个参数是标识流中每个条目的条目ID。
但是，在本例中，我们通过了*因为我们希望服务器为我们生成一个新的ID。
每一个新的ID都会单调地增加，所以用更简单的话来说，每一个新添加的条目都会比所有以前的条目有一个更高的ID。
服务器自动生成ID几乎总是您想要的，显式指定ID的原因非常少。我们稍后再谈这个。
每个流条目都有一个ID这一事实与日志文件是另一个相似之处，在日志文件中，可以使用行号或文件中的字节偏移量来标识给定条目。
回到我们的XADD示例，在键名和ID之后，下一个参数是组成流条目的字段-值对。

只需使用XLEN命令就可以获得流中的项数：

    > XLEN mystream
    (integer) 1

## ID条目

XADD命令返回的条目ID由两部分组成，单独标识给定流中的每个条目：

    <millisecondsTime>-<sequenceNumber>

毫秒时间部分实际上是生成流ID的本地KeyDB节点中的本地时间，但是如果当前毫秒时间恰好小于上一个条目时间，
则使用上一个条目时间，因此如果时钟向后跳，则单调递增ID属性仍然保持。
序列号用于在相同毫秒内创建的条目。由于序列号是64位宽的，实际上，在同一毫秒内可以生成的条目数没有限制。

这种ID的格式一开始可能看起来很奇怪，温和的读者可能会想为什么时间是ID的一部分。
原因是KeyDB流支持按ID进行范围查询。由于ID与生成条目的时间相关，这使得基本上可以免费查询时间范围。
我们将很快在报道XRANGE命令时看到这一点。

如果出于某种原因，用户需要与时间无关但实际与另一个外部系统ID关联的增量ID（如前所述），则XADD命令可以采用显式ID，
而不是触发自动生成的*通配符ID，如下例所示：

    > XADD somestream 0-1 field value
    0-1
    > XADD somestream 0-2 foo bar
    0-2

注意，在这种情况下，最小ID为0-1，并且命令将不接受等于或小于前一个ID的ID：

    > XADD somestream 0-1 foo bar
    （错误）ERR The ID specified in XADD is equal or smaller than the target stream top item

## 从流中获取数据

现在我们终于可以通过XADD在流中追加条目了。然而，虽然将数据附加到流是非常明显的，但是查询流以提取数据的方式却不那么明显。
如果我们继续模拟日志文件，一个明显的方法是模拟我们通常使用Unix命令tail -f执行的操作，也就是说，我们可以开始监听，以便获取附加到流的新消息。
注意，与KeyDB的阻塞列表操作不同，在这里，给定的元素将到达一个在像BLPOP这样的pop风格操作中阻塞的客户端，我们希望多个使用者可以看到附加到流的新消息，
就像许多tail -f进程可以看到添加到日志中的内容一样。使用传统术语，我们希望流能够将消息扇出到多个客户端。

然而，这只是一种潜在的访问模式。我们还可以用完全不同的方式看到流：不是作为消息传递系统，而是作为时间序列存储。
在这种情况下，附加新消息可能也很有用，但另一种自然的查询模式是按时间范围获取消息，或者使用光标迭代消息以增量检查所有历史记录。
这绝对是另一种有用的访问模式。

最后，如果我们从消费者的角度看一个流，我们可能希望以另一种方式访问该流，也就是说，作为一个消息流，可以将其划分为正在处理此类消息的多个消费者，
以便消费者组只能看到在单个流中到达的消息的子集。这样，就可以在不同的使用者之间扩展消息处理，
而无需单个使用者处理所有消息：每个使用者只需处理不同的消息。这基本上就是kafka（Kafka，TM）对消费者群体所做的。
通过消费者组读取消息是从KeyDB流读取消息的另一个有趣模式。

KeyDB流通过不同的命令支持上述三种查询模式。接下来的部分将显示所有这些查询，从最简单和更直接的使用开始：范围查询。

## 按范围查询：XRANGE和XREVRANGE

要按范围查询流，我们只需要指定两个id，start和end。返回的范围将包括以ID开头或结尾的元素，因此范围是包含的。
两个特殊的IDs - 和 + 分别表示可能的最小ID和最大ID。

    > XRANGE mystream - +
    1) 1) 1518951480106-0
       2) 1) "sensor-id"
          2) "1234"
          3) "temperature"
          4) "19.8"
    2) 1) 1518951482479-0
       2) 1) "sensor-id"
          2) "9999"
          3) "temperature"
          4) "18.2"

返回的每个条目都是由两个项组成的数组：ID和字段-值对列表。我们已经说过条目id与时间有关系，因为-字符左边的部分是创建流条目的本地节点在创建条目时的Unix时间（以毫秒为单位）
（但是请注意，流是用完全指定的XADD命令复制的，所以slave和主人的身份是一样的。这意味着我可以使用XRANGE查询一个时间范围。
然而，为了做到这一点，我可能想要省略ID的序列部分：如果省略，在开始的范围内，它将被假定为0，而在最后部分将被假定为可用的最大序列号。
这样，只使用两毫秒的Unix时间进行查询，我们就可以以包含的方式获取在该时间范围内生成的所有条目。
例如，我可能想查询一个可以使用的两毫秒时间段：

    > XRANGE mystream 1518951480106 1518951480107
    1) 1) 1518951480106-0
       2) 1) "sensor-id"
          2) "1234"
          3) "temperature"
          4) "19.8"

在这个范围内我只有一个条目，但是在实际的数据集中，我可以查询小时的范围，或者在两毫秒内有很多条目，返回的结果可能是巨大的。
因此，XRANGE在末尾支持一个可选的COUNT选项。通过指定一个计数，我可以得到前N个项目。
如果我想要更多，我可以得到返回的最后一个ID，将序列部分增加一个，然后再次查询。
让我们在下面的例子中看到这一点。我们开始使用XADD添加10个项（我不会显示，已经假设流mystream填充了10个项）。
要开始迭代，每个命令获取2个项，我从完整范围开始，但计数为2。        

    > XRANGE mystream - + COUNT 2
    1) 1) 1519073278252-0
       2) 1) "foo"
          2) "value_1"
    2) 1) 1519073279157-0
       2) 1) "foo"
          2) "value_2"

为了继续下两个项的迭代，我必须选择返回的最后一个ID，即1519073279157-0，并将1添加到ID的序列号部分。
请注意，序列号是64位的，因此不需要检查溢出。结果ID（在本例中为1519073279157-1）现在可以用作下一个XRANGE调用的新start参数：      
 
    > XRANGE mystream 1519073279157-1 + COUNT 2
    1) 1) 1519073280281-0
       2) 1) "foo"
          2) "value_3"
    2) 1) 1519073281432-0
       2) 1) "foo"
          2) "value_4"

等等。由于XRead复杂度是O（log（n））来搜索，然后O（m）返回m个元素，所以用一个小的计数命令具有对数时间复杂度，这意味着迭代的每个步骤都是快速的。
因此，XRANGE也是事实上的流迭代器，不需要XSCAN命令。

命令XREVRANGE相当于XRANGE，但返回的元素顺序相反，因此XREVRANGE的实际用途是检查流中的最后一项是什么：      

    > XREVRANGE mystream + - COUNT 1
    1) 1) 1519073287312-0
       2) 1) "foo"
          2) "value_10"

注意，XREVRANGE命令以相反的顺序接受start和stop参数。                
                
## 使用XREAD监听新条目

当我们不想通过流中的一个范围访问项时，通常我们想要的是订阅到达流的新项。
这个概念可能与KeyDB Pub/Sub（您订阅频道）或 KeyDB阻塞列表（您等待键获取要获取的新元素）有关，但在使用流的方式上存在根本的差异：

    1.一个流可以有多个client（消费者）等待数据。默认情况下，每个新项都将传递给在给定流中等待数据的每个消费者。
    这种行为与阻塞列表不同，在阻塞列表中，每个使用者将获得不同的元素。然而，向多个消费者扇出的能力类似于Pub/Sub。
    
    2.虽然Pub/Sub中的消息是激发和遗忘的，并且永远不会被存储，而且当使用阻塞列表时，当客户机接收到一条消息时，它会从列表中弹出（有效地删除），但是流的工作方式是完全不同的。
    所有消息都无限期地附加在流中（除非用户明确要求删除条目）：不同的使用者将通过记住最后接收到的消息的ID从其角度知道什么是新消息。
    
    3.流消费者组提供了Pub/Sub或blocking list无法实现的控制级别，对于同一流有不同的组，可以显式地确认已处理的项、检查待处理项的能力、声称未处理的消息以及每个客户端的一致历史可见性，
    这只能看到它过去的私人信息历史。

提供监听到达流中的新消息的能力的命令称为XREAD。
它比XRANGE复杂一些，所以我们将开始显示简单的表单，稍后将提供整个命令布局。

    > XREAD COUNT 2 STREAMS mystream 0
    1) 1) "mystream"
       2) 1) 1) 1519073278252-0
             2) 1) "foo"
                2) "value_1"
          2) 1) 1519073279157-0
             2) 1) "foo"
                2) "value_2"

以上是XREAD的非阻塞形式。注意，计数选项不是强制的，事实上，命令的唯一强制选项是流选项，它指定了一个键列表以及由调用用户已经看到的每个流所对应的最大ID。
这样，该命令将只向客户端提供ID大于我们指定的ID的消息。

在上面的命令中，我们编写了STREAMS mystream 0，因此我们希望流mystream中的所有消息的ID都大于0-0。正如您在上面的示例中所看到的，该命令返回key名，
因为实际上可以用多个key调用该命令，以便同时从不同的流中读取。我可以写，例如：STREAMS mystream otherstream 0 0。
注意STREAMS选项之后，我们需要提供key名称，以及随后的id。因此，STREAMS选项必须始终是最后一个选项。

除了XREAD可以同时访问多个流，并且我们可以指定我们拥有的最后一个ID来获取更新的消息之外，在这个简单的表单中，该命令与XRANGE没有太大的不同。
不过，有趣的是，通过指定BLOCK参数，我们可以很容易地在BLOCK命令中打开XREAD：

    > XREAD BLOCK 0 STREAMS mystream $                
     
注意，在上面的示例中，除了删除COUNT之外，我还指定了超时为0毫秒的新BLOCK选项（这意味着永远不会超时）。此外，我没有为流mystream传递普通ID，而是传递了特殊ID$。这个特殊ID意味着XRead应该使用已经存储在流MySt流中的最大ID作为最后ID，这样我们将只从开始侦听的时间开始接收新的消息。这在某种程度上类似于tail-f Unix命令。

注意，当使用BLOCK选项时，我们不必使用特殊ID$。我们可以使用任何有效的ID。如果命令能够立即服务于我们的请求而不被阻塞，它将这样做，否则它将被阻塞。
通常，如果我们想使用从新条目开始的流，我们将从ID$开始，然后继续使用接收到的最后一条消息的ID进行下一次调用，以此类推。

XREAD的阻塞形式还可以监听多个流，只需指定多个密钥名。如果请求可以同步服务，因为至少有一个流的元素大于我们指定的相应ID，那么它将返回结果。
否则，该命令将阻塞并返回获得新数据的第一个流的项（根据指定的ID）。

与阻塞列表操作类似，从等待数据的客户端的角度来看，阻塞流读取是公平的，因为语义是FIFO风格的。
第一个为给定流阻止的客户端是第一个在新项目可用时将被取消阻止的客户端。

XREAD除了COUNT和BLOCK之外没有其他选项，因此它是一个非常基本的命令，其特定目的是攻击一个或多个流的使用者。
使用consumer groups API可以使用更强大的功能来使用流，但是通过consumer groups进行的读取是由一个名为XREADGROUP的不同命令实现的，
本指南的下一节将介绍这个命令。                    
                    
## 消费者组

当手头的任务是使用来自不同客户机的相同流时，XREAD已经提供了一种扇出到N个客户机的方法，可能还使用slave来提供更多的读取可伸缩性。
然而，在某些问题中，我们要做的不是向许多客户机提供相同的消息流，而是向许多客户机提供来自同一流的不同消息子集。
这一点很有用的一个明显的例子是消息处理速度慢：通过将不同的消息路由到准备好做更多工作的不同的工作人员，能够让N个不同的工作人员接收流的不同部分，从而允许扩展消息处理。

实际上，如果我们设想有三个消费者C1、C2、C3和一个包含消息1、2、3、4、5、6、7的流，那么我们想要的是像下图中那样提供消息：

    1 -> C1
    2 -> C2
    3 -> C3
    4 -> C1
    5 -> C2
    6 -> C3
    7 -> C1

为了获得这种效果，KeyDB使用了一个称为消费者组的概念。从Kafka（TM）消费者群体的实现角度来看，KeyDB消费者群体与之无关，这一点非常重要，但从他们实现的概念来看，
它们只是相似的，因此，我决定与最初推广这种想法的软件产品相比，不改变术语。

一个消费者群体就像一个从流中获取数据的伪消费者，实际上为多个消费者提供服务，并提供一定的保证：

1.每个消息都被服务于不同的使用者，因此不可能将同一消息传递给多个使用者。

2.在消费者组中，消费者由一个名称标识，该名称是实现消费者的客户机必须选择的区分大小写的字符串。
这意味着，即使断开连接，流消费者组仍保留所有状态，因为客户端将再次声明为同一消费者。
但是，这也意味着由client提供唯一的标识符。

3.每个消费者组都有一个从未使用过的第一个ID的概念，这样，当消费者请求新消息时，它可以只提供以前从未传递过的消息。

4.但是，使用消息需要使用特定命令进行显式确认，即：此消息已正确处理，因此可以从使用者组中逐出。

5.使用者组跟踪当前挂起的所有消息，即传递给使用者组的某个使用者但尚未确认为已处理的消息。
由于此功能，当访问流的消息历史记录时，每个消费者将只看到传递给它的消息。

在某种程度上，消费者群体可以想象为流的某种状态：

    +----------------------------------------+
    | consumer_group_name: mygroup           |
    | consumer_group_stream: somekey         |
    | last_delivered_id: 1292309234234-92    |
    |                                        |
    | consumers:                             |
    |    "consumer-1" with pending messages  |
    |       1292309234234-4                  |
    |       1292309234232-8                  |
    |    "consumer-42" with pending messages |
    |       ... (and so forth)               |
    +----------------------------------------+

如果从这个角度来看，很容易理解消费者组可以做什么，它如何能够向消费者提供其挂起消息的历史记录，
以及如何向要求新消息的消费者提供的消息id将大于上次last_delivered_id KEYDB流的辅助数据结构，很明显，单个流可以具有多个消费者组，
它们具有不同的消费者集合。实际上，同一个流甚至可以让客户机通过XREAD在没有消费者组的情况下阅读，
而client在不同消费者组中通过XREADGROUP阅读。

现在是放大以查看基本消费者组命令的时候了，这些命令如下：

* XGROUP用于创建、销毁和管理消费者组。
* XREADGROUP用于通过消费者组从流中读取数据。
* XACK是允许使用者将挂起消息标记为已正确处理的命令。

## 创建消费者组

假设我有一个已经存在的key流类型，为了创建一个消费组，我需要做如下操作：

    > XGROUP CREATE mystream mygroup $
    OK

注意：目前不可能为不存在的流创建消费组，但是在短期内，我们可能会向XGROUP命令添加一个选项，以便在这种情况下创建空流。

正如您在上面的命令中看到的，在创建消费者组时，我们必须指定一个ID，在本例中，它只是$。
这是必需的，因为在其他状态中，使用者组必须知道在第一个使用者连接时接下来要服务的消息，也就是说，当组刚刚创建时，当前的最后一个消息ID是什么？
如果我们像以前那样提供$，那么从现在起只会向组中的消费者提供到达流中的新消息。
如果改为指定0，则使用者组将使用流历史记录中的所有消息。当然，您可以指定任何其他有效的ID。
您知道的是，使用者组将开始传递大于您指定的ID的消息。因为$表示流中当前最大的ID，所以指定$将只消耗新消息。

现在已经创建了使用者组，我们可以立即开始尝试通过使用者组读取消息，方法是使用XREADGROUP命令。
我们将从消费者那里了解到，我们将调用Alice和Bob，以了解系统将如何向Alice和Bob返回不同的消息。

XREADGROUP与yo XREAD非常相似，并提供相同的块选项，否则它是一个同步命令。
但是，必须始终指定一个强制选项，该选项是GROUP，并且有两个参数：使用者组的名称和试图读取的使用者的名称。
选项计数也受支持，与XREAD中的相同。

在从流中读取之前，让我们在其中放置一些消息：

    > XADD mystream * message apple
    1526569495631-0
    > XADD mystream * message orange
    1526569498055-0
    > XADD mystream * message strawberry
    1526569506935-0
    > XADD mystream * message apricot
    1526569535168-0
    > XADD mystream * message banana
    1526569544280-0

注意：这里的消息是字段名，水果是关联值，记住流项是小字典。

现在是时候尝试使用消费者群体阅读一些东西了：

    > XREADGROUP GROUP mygroup Alice COUNT 1 STREAMS mystream >
    1) 1) "mystream"
       2) 1) 1) 1526569495631-0
             2) 1) "message"
                2) "apple"

XREADGROUP回复就像XREAD回复一样。注意，但是上面提供的GROUP<GROUP name><consumer name>声明我想使用consumer GROUP mygroup从流中读取，我是consumer Alice。
每次使用者对使用者组执行操作时，它必须指定其名称以唯一标识组内的此使用者。

在上面的命令行中还有一个非常重要的细节，在强制流选项之后，为键mystream请求的ID是特殊ID>。这个特殊的ID只在消费者组的上下文中有效，
它的意思是：到目前为止从未传递给其他消费者的消息。

这几乎总是您想要的，但是也可以指定一个真实的ID，例如0或任何其他有效的ID，在这种情况下，我们请求XREADGROUP只提供挂起消息的历史记录，
在这种情况下，永远不会在组中看到新消息。因此，基本上XREADGROUP基于我们指定的ID有以下行为：                

    * 如果ID是特殊ID>，那么该命令将只返回迄今为止从未传递给其他使用者的新消息，并且作为副作用，将更新使用者组last ID。
    * 如果ID是任何其他有效的数字ID，那么该命令将允许我们访问挂起消息的历史记录。也就是说，
    传递给这个指定使用者（由提供的名称标识）并且到目前为止从未用XACK确认过的一组消息。

我们可以立即测试此行为，指定ID为0，而不使用任何COUNT选项：我们只会看到唯一挂起的消息，即关于apples的消息：

    > XREADGROUP GROUP mygroup Alice STREAMS mystream 0
    1) 1) "mystream"
       2) 1) 1) 1526569495631-0
             2) 1) "message"
                2) "apple"

但是，如果我们确认消息已处理，它将不再是挂起消息历史记录的一部分，因此系统将不再报告任何内容：                
    
    > XACK mystream mygroup 1526569495631-0
    (integer) 1
    > XREADGROUP GROUP mygroup Alice STREAMS mystream 0
    1) 1) "mystream"
       2) (empty list or set)                

如果您还不知道XACK是如何工作的，不要担心，概念是处理的消息不再是我们可以访问的历史的一部分。

现在轮到Bob读点东西了：                    
  
    > XREADGROUP GROUP mygroup Bob COUNT 2 STREAMS mystream >
    1) 1) "mystream"
       2) 1) 1) 1526569498055-0
             2) 1) "message"
                2) "orange"
          2) 1) 1526569506935-0
             2) 1) "message"
                2) "strawberry"                    

Bob请求最多两条消息，并通过同一组MyGROUP读取。因此，KeyDB只报告新消息。
正如你所看到的，"apple"的信息没有传递，因为它已经传递给Alice，所以Bob得到了orange和strawberry，等等。

这样，Alice、Bob和组中的任何其他消费者都可以从同一流中读取不同的消息，
读取其尚未处理消息的历史记录，或者将消息标记为已处理。这允许创建不同的拓扑和语义来使用流中的消息。

有几件事要记住 :
                       
* 消费者在第一次被提及时是自动创建的，不需要显式创建。
* 即使使用XREADGROUP，您也可以同时读取多个密钥，但是要使其生效，您需要在每个流中创建一个同名的使用者组。
  这不是常见的需求，但值得一提的是，该功能在技术上是可用的。
* XREADGROUP是一个写命令，因为即使它从流中读取，使用者组也会被修改为读取的副作用，因此只能在主实例中调用它。                       

下面是用Ruby语言编写的使用使用者组的使用者实现示例。Ruby代码的编写方式可以让几乎所有有经验的程序员在使用其他语言进行编程时都能读懂，
但他们并不了解Ruby：
                        
    require 'redis'
    
    if ARGV.length == 0
        puts "Please specify a consumer name"
        exit 1
    end
    
    ConsumerName = ARGV[0]
    GroupName = "mygroup"
    r = redis.new
    
    def process_message(id,msg)
        puts "[#{ConsumerName}] #{id} = #{msg.inspect}"
    end
    
    $lastid = '0-0'
    
    puts "Consumer #{ConsumerName} starting..."
    check_backlog = true
    while true
        # Pick the ID based on the iteration: the first time we want to
        # read our pending messages, in case we crashed and are recovering.
        # Once we consumer our history, we can start getting new messages.
        if check_backlog
            myid = $lastid
        else
            myid = '>'
        end
    
        items = r.xreadgroup('GROUP',GroupName,ConsumerName,'BLOCK','2000','COUNT','10','STREAMS',:my_stream_key,myid)
        
        if items == nil
            puts "Timeout!"
            next
        end
    
        # If we receive an empty reply, it means we were consuming our history
        # and that the history is now empty. Let's start to consume new messages.
        check_backlog = false if items[0][1].length == 0
        
        items[0][1].each{|i|
            id,fields = i
    
            # Process the message
            process_message(id,fields)
    
            # Acknowledge the message as processed
            r.xack(:my_stream_key,GroupName,id)
    
            $lastid = id
        }
    end

如您所见，这里的想法是开始使用历史记录，即我们的待处理邮件列表。这很有用，因为使用者以前可能已经崩溃，所以在重新启动的情况下，我们希望再次读取传递给我们的消息，而不会得到确认。
这样，我们可以多次或一次处理消息（至少在使用者失败的情况下是这样，但是还涉及KeyDB持久性和复制的限制，请参阅有关此主题的特定部分）。

一旦使用了历史记录，并且得到了一个空的消息列表，我们就可以切换到使用 > special ID 来使用新消息。                        
                        
## 从永久故障中恢复

上面的示例允许我们将参与同一消费者组的消费者写入，将每个消息的子集进行处理，并从失败中恢复，重新读取仅传递给他们的挂起消息。
然而，在现实世界中，消费者可能永远失败，永远无法恢复。消费者因任何原因停止后无法恢复的挂起消息会发生什么情况？

KeyDB使用者组提供了一个在这种情况下完全使用的功能，以便声明给定使用者的挂起消息，这样这些消息将更改所有权并重新分配给其他使用者。
该功能非常明确，使用者必须检查挂起的消息列表，并且必须使用特殊命令声明特定的消息，否则服务器将永远将挂起的消息分配给旧使用者，
这样不同的应用程序可以选择是否使用该功能，以及正确的使用方法。

此过程的第一步只是一个命令，它提供使用者组中挂起项的可观察性，称为XPENDING。
这只是一个只读命令，调用起来总是安全的，不会更改任何消息的所有权。在最简单的形式中，
命令只是用两个参数调用的，这两个参数是流的名称和使用者组的名称。

    > XPENDING mystream mygroup
    1) (integer) 2
    2) 1526569498055-0
    3) 1526569506935-0
    4) 1) 1) "Bob"
          2) "2"

当以这种方式调用时，该命令只输出使用者组中挂起消息的总数，在这种情况下，只输出两条消息，即挂起消息中较低和较高的消息ID，
最后输出使用者列表和它们拥有的挂起消息数。我们只有Bob有两条挂起的消息，因为Alice请求的唯一消息是使用XACK确认的。

我们可以通过为XPENDING提供更多参数来获取更多信息，因为完整的命令签名如下：

    XPENDING <key> <groupname> [<start-id> <end-id> <count> [<consumer-name>]]

通过提供start和end ID（在XRANGE中可以是-and+）以及控制命令返回的信息量的计数，我们能够了解更多关于挂起消息的信息。
如果我们希望将输出限制为仅对给定使用者组挂起的消息，则使用可选的最终参数consumer group name，但在下面的示例中不使用此功能。

    > XPENDING mystream mygroup - + 10
    1) 1) 1526569498055-0
       2) "Bob"
       3) (integer) 74170458
       4) (integer) 1
    2) 1) 1526569506935-0
       2) "Bob"
       3) (integer) 74170458
       4) (integer) 1

现在我们有了每条消息的详细信息：ID、使用者名称、空闲时间（以毫秒为单位），这是自上次将消息传递给某个使用者以来经过的毫秒数，最后是传递给定消息的次数。
我们有两条来自Bob的消息，它们空闲74170458毫秒，大约20小时。

注意，没有人阻止我们检查第一条消息的内容是什么，只是使用了XRANGE。
 
    > XRANGE mystream 1526569498055-0 1526569498055-0
    1) 1) 1526569498055-0
       2) 1) "message"
          2) "orange"       

我们只需在参数中重复相同的ID两次。现在我们有了一些想法，Alice可能会决定，在20个小时不处理消息之后，Bob可能不会及时恢复，
现在是声明这些消息并代替Bob恢复处理的时候了。为此，我们使用xclam命令。

这个命令非常复杂，并且充满了完整形式的选项，因为它用于复制使用者组更改，但是我们将只使用通常需要的参数。
在这种情况下，只需这样调用它：
       
    XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2> ... <ID-N>       

基本上，我们说，对于这个特定的键和组，我希望指定的消息id将更改所有权，并将分配给指定的使用者名称<consumer>。
但是，我们还提供了一个最小的空闲时间，因此只有当上述消息的空闲时间大于指定的空闲时间时，该操作才会工作。
这很有用，因为可能有两个客户端正在重试同时声明消息：
       
    Client 1: XCLAIM mystream mygroup Alice 3600000 1526569498055-0
    Clinet 2: XCLAIM mystream mygroup Lora 3600000 1526569498055-0

不过声称一条消息，作为副作用会重置其空闲时间！并将增加其传递计数器的数量，因此第二个client将无法对其进行索赔。
这样，我们就避免了对消息的琐碎的重新处理（即使在一般情况下，您不能只获得一次处理）。

这是命令执行的结果：           

    > XCLAIM mystream mygroup Alice 3600000 1526569498055-0
    1) 1) 1526569498055-0
       2) 1) "message"
          2) "orange"

Alice成功地声明了该消息，它现在可以处理并确认该消息，并且即使原始消费者没有恢复，也可以向前移动。

从上面的示例可以清楚地看到，作为成功声明给定消息的副作用，XCLAIM命令还返回该消息。
但这不是强制性的。JUSTID选项可用于仅返回成功声明的消息的id。如果您希望减少客户端和服务器之间使用的带宽，
同时降低命令的性能，并且您对该消息不感兴趣，这将非常有用，因为稍后您的使用者将以一种将不时重新扫描挂起消息的历史的方式实现。

声明也可以通过一个单独的过程实现：一个只检查挂起消息列表，并将空闲消息分配给似乎处于活动状态的消费者的过程。
利用KeyDB流的一个可观测性特征可以获得活动用户。这是下一节的主题。                
                
## 认领(断言) 和 传送计数器

在XPENDING输出中观察到的计数器是每条消息的传递数。
这种计数器以两种方式递增：当通过XCLAIM成功声明消息时，或者当使用XREADGROUP调用来访问挂起消息的历史记录时。

当出现故障时，多次传递消息是正常的，但最终通常会得到处理。
但是，有时处理给定的特定消息时会出现问题，因为该消息已损坏或精心编制的方式会触发处理代码中的错误。
在这种情况下，发生的情况是，消费者将继续无法处理这个特定的消息。
因为我们有传递尝试的计数器，所以可以使用该计数器检测由于某种原因根本无法处理的消息。
因此，一旦deliveries计数器达到您选择的给定大数目，将此类消息放入另一个流中并向系统管理员发送通知可能会更明智。
这基本上是KeyDB流实现死信概念的方式。

## Streams 流可观察性

缺乏可观察性的消息传递系统很难使用。不知道谁在使用消息，什么消息正在等待，在给定的流中活动的消费者组集合，使得一切都不透明。
因此，KeyDB流和消费者组有不同的方式来观察正在发生的事情。我们已经介绍了XPENDING，
它允许我们检查在给定时刻正在处理的消息列表，以及它们的空闲时间和传递次数。

不过，我们可能还需要做更多的工作，XINFO命令是一个可观察的接口，可以与子命令一起使用，以获取有关流或使用者组的信息。

此命令使用子命令来显示有关流及其使用者组的状态的不同信息。例如，使用XINFO STREAM报告有关流本身的信息。

    > XINFO STREAM mystream
     1) length
     2) (integer) 13
     3) radix-tree-keys
     4) (integer) 1
     5) radix-tree-nodes
     6) (integer) 2
     7) groups
     8) (integer) 2
     9) first-entry
    10) 1) 1524494395530-0
        2) 1) "a"
           2) "1"
           3) "b"
           4) "2"
    11) last-entry
    12) 1) 1526569544280-0
        2) 1) "message"
           2) "banana"
           
输出显示流如何在内部编码的信息，还显示流中的第一条和最后一条消息。
另一个可用信息是与此流值关联的使用者组数。我们可以进一步深入了解有关消费群体的更多信息。

    > XINFO GROUPS mystream
    1) 1) name
       2) "mygroup"
       3) consumers
       4) (integer) 2
       5) pending
       6) (integer) 2
    2) 1) name
       2) "some-other-group"
       3) consumers
       4) (integer) 1
       5) pending
       6) (integer) 0
       
正如您在本输出和上一个输出中看到的，XINFO命令输出一系列字段值项。
因为它是一个可观察的命令，这允许人类用户立即了解报告的信息，并允许该命令通过添加更多字段来报告更多信息，而不会破坏与旧客户端的兼容性。
其他必须更节省带宽的命令，例如XPENDING，只报告不带字段名的信息。

在上面的示例中，使用GROUPS子命令时，其输出应该是清晰的，即观察字段名。
我们可以通过检查在该组中注册的消费者来更详细地检查特定消费者组的状态。

    > XINFO CONSUMERS mystream mygroup
    1) 1) name
       2) "Alice"
       3) pending
       4) (integer) 1
       5) idle
       6) (integer) 9104628
    2) 1) name
       2) "Bob"
       3) pending
       4) (integer) 1
       5) idle
       6) (integer) 83841983

如果您不记得命令的语法，请向命令本身寻求帮助：
       
    > XINFO HELP
    1) XINFO <subcommand> arg arg ... arg. Subcommands are:
    2) CONSUMERS <key> <groupname>  -- Show consumer groups of group <groupname>.
    3) GROUPS <key>                 -- Show the stream consumer groups.
    4) STREAM <key>                 -- Show information about the stream.
    5) HELP                         -- Print this help.
           
## 与Kafka（TM）分区的区别

KeyDB流中的使用者组在某种程度上类似于基于Kafka（TM）分区的使用者组，但是注意KeyDB流实际上是非常不同的。
分区只是逻辑的，消息只是放在一个KeyDB键中，因此服务不同客户机的方式取决于谁准备好处理新消息，而不是客户机从哪个分区读取。
例如，如果使用者C3在某个时刻永久性地失败，KeyDB将继续为C1服务，C2将所有新消息到达，就好像现在只有两个逻辑分区一样。

同样，如果给定的使用者比其他使用者处理消息的速度快得多，则该使用者将在同一时间单位中按比例接收更多的消息。
这是可能的，因为KeyDB显式地跟踪所有未确认的消息，并记住谁接收了哪条消息以及第一条消息的ID从未传递给任何消费者。

但是，这也意味着在KeyDB中，如果您真的想将关于同一流的消息划分为多个KeyDB实例，那么您必须使用多个key和一些分片系统，
例如KeyDB Cluster或一些其他特定于应用程序的分片系统。单个KeyDB流不会自动分区到多个实例。

我们可以简略地说，以下情况是正确的：

* 如果使用1个 stream->1个 consumer，则按顺序处理消息。
* 如果将N个流与N个消费者一起使用，那么只有给定的消费者访问N个流的子集，则可以缩放上述1个流->1个消费者的模型。
* 如果您使用1 stream->N consumer，则您正在对N个consumer进行负载平衡，但是在这种情况下，关于同一逻辑项的消息可能会被无序使用，
  因为给定的consumer处理消息3的速度可能比另一个consumer处理消息4的速度快。

所以基本上Kafka分区更类似于使用N个不同的KeyDB键。KeyDB使用者组是一个服务器端的负载平衡系统，
它将来自给定流的消息分配给N个不同的使用者。

## Streams 流封顶

许多应用程序不希望永远将数据收集到流中。有时在一个流中有一个给定数量的项目是有用的，其他时候，一旦达到给定的大小，
将数据从KEDB迁移到一个不在内存中的存储器中是有用的，而不是快速的，但它适合于潜在的未来几十年的历史。
KeyDB流对此有一些支持。XADD命令的MAXLEN选项之一。这样的选择非常简单：

    > XADD mystream MAXLEN 2 * value 1
    1526654998691-0
    > XADD mystream MAXLEN 2 * value 2
    1526654999635-0
    > XADD mystream MAXLEN 2 * value 3
    1526655000369-0
    > XLEN mystream
    (integer) 2
    > XRANGE mystream - +
    1) 1) 1526654999635-0
       2) 1) "value"
          2) "2"
    2) 1) 1526655000369-0
       2) 1) "value"
          2) "3"

使用MAXLEN，当达到指定的长度时，旧的条目将被自动收回，以便以恒定的大小获取流。
目前没有任何选项可以告诉流只保留不早于给定数量的项，因为这样的命令为了一致地运行，可能需要阻塞很长时间才能收回项。
例如，如果插入尖峰、长暂停和另一个插入都发生相同的最大时间，则会发生什么情况。
流将阻塞以逐出暂停期间变得太旧的数据。因此，用户需要做一些规划并了解所需的最大流长度是多少。
此外，虽然流的长度与所使用的内存成比例，但按时间修剪不太容易控制和预期：它取决于插入率，而插入率是一个经常随时间变化的变量（当插入率不变时，仅按大小修剪就无关紧要）。

但是，使用MAXLEN进行修剪可能会很昂贵：流由宏节点表示为基数树，以便非常节省内存。
改变由几十个元素组成的单个宏节点不是最优的。因此，可以用以下特殊形式发出命令：

    XADD mystream MAXLEN ~ 1000 * ... entry fields here ...

MAXLEN选项和实际计数之间 ~ 参数意味着，我不需要它是1000个项目。它可以是1000或1010或1030，只要确保至少保存1000个项目。
使用此参数，仅当可以移除整个节点时才执行修剪。这使它更有效，而且通常是你想要的。

还有一个XTRIM命令，它执行与上面MAXLEN选项非常相似的操作，但是这个命令不需要给出任何东西，可以独立地对任何流运行。

    > XTRIM mystream MAXLEN 10

或者，对于XADD选项：

    > XTRIM mystream MAXLEN ~ 10

然而，XTRIM被设计成接受不同的修剪策略，即使目前只有MAXLEN被实现。
鉴于这是一个显式命令，将来可能允许指定按时间修剪，因为以独立方式调用此命令的用户应该知道自己在做什么。

XTRIM应该具有的一个有用的逐出策略可能是通过一系列id移除的能力。
这目前是不可能的，但将来可能会实现，以便在需要时更容易地使用XRANGE和XTRIM将数据从KeyDB移动到其他存储系统。

## Streams API中的特殊id

您可能已经注意到KeyDB API中可以使用几个特殊的id。这里有一个简短的概述，这样他们可以在未来更有意义。

前两个特殊id是-和+，用于使用XRANGE命令的范围查询。这两个ID分别表示可能的最小ID（基本上是0-1）和可能的最大ID（即18446744073709551615-18446744073709551615）。
正如你所看到的，用-和+来代替那些数字要干净得多。

还有一些api，我们想说，流中ID最大的项的ID。这就是$的意思。例如，如果我只想使用XeReGoad新的实体，我使用这样的ID来告诉我，
我已经拥有了所有现有的条目，而不是将来要插入的消息。类似地，当我创建或设置消费者组的ID时，我可以将最后交付的项设置为$，
以便仅使用该组向消费者交付新的实体。

正如您所看到的，$并不意味着+，它们是两个不同的东西，因为+是每个可能流中最大的ID，而$是包含给定项的给定流中最大的ID。
此外，api通常只理解+或$，但是避免加载具有多个含义的给定符号是有用的。

另一个特殊的ID是>，只有在使用XREADGROUP命令时，它才具有特殊的含义。
如此特殊的身份证意味着我们只想要迄今为止从未交付给其他消费者的实体。所以基本上，>ID是消费者组的最后一个交付ID。

最后，只能与XADD命令一起使用的特殊ID*意味着为我们要创建的新条目自动选择一个ID。

所以我们有-、+、$、>和*，并且都有不同的含义，大多数时候，只能在不同的上下文中使用。

## 持久性、复制和消息安全

流与任何其他KeyDB数据结构一样，被异步复制到从服务器并持久化到AOF和RDB文件中。
然而，可能不那么明显的是，消费者组full状态也会传播到AOF、RDB和从机，因此，如果消息在主机中挂起，则从机也将具有相同的信息。
类似地，在重新启动之后，AOF将恢复消费者组状态。

但是请注意，KeyDB流和使用者组是使用KeyDB默认复制持久化和复制的，因此：

* 如果消息的持久性在应用程序中很重要，则必须将aof与强fsync策略一起使用。

* 默认情况下，异步复制不能保证复制XADD命令或使用者组状态更改：在故障转移之后，可能会丢失一些内容，具体取决于从机从主机接收数据的能力。

* WAIT命令可用于强制将更改传播到一组从机。然而，请注意，虽然这使得数据丢失的可能性非常小，但是由Sentinel或KeyDB集群操作的KeyDB故障转移过程只执行最大努力检查，以便故障转移到最新的从机，并且在某些特定故障下，可能会提升缺少某些数据的从机。

因此，在使用KeyDB流和使用者组设计应用程序时，请确保理解应用程序在故障期间应该具有的语义属性，
并相应地配置一些内容，评估它是否足够安全，适合您的用例。

## 从流中移除单个项

流还具有一个特殊的命令，仅通过ID从流的中间移除项。通常对于只附加的数据结构，这看起来可能是一个奇怪的特性，
但实际上对于涉及隐私规则的应用程序非常有用。该命令名为XDEL，只获取流的名称和要删除的id：

    > XRANGE mystream - + COUNT 2
    1) 1) 1526654999635-0
       2) 1) "value"
          2) "2"
    2) 1) 1526655000369-0
       2) 1) "value"
          2) "3"
    > XDEL mystream 1526654999635-0
    (integer) 1
    > XRANGE mystream - + COUNT 2
    1) 1) 1526655000369-0
       2) 1) "value"
          2) "3"

但是在当前实现中，只有宏节点完全为空时，才能真正回收内存，因此不应滥用此功能。      
      
## 零长度流

streams和其他KeyDB数据结构的区别在于，当其他数据结构不再具有元素时，作为调用删除元素的命令的副作用，键本身将被删除。
例如，当调用ZREM将删除排序集中的最后一个元素时，排序集将被完全删除。相反，由于使用了计数为零的MAXLEN选项（XADD和XTRIM命令），
或者由于调用了XDEL，流可以保持在零元素。

之所以存在这样的不对称性，是因为流可能有关联的消费群体，并且我们不希望失去消费者组定义的状态，仅仅因为流中不再有项目。
当前流即使没有关联的消费者组也不会被删除，但将来可能会发生变化。

## 使用消息的总延迟

非阻塞流命令，如xWalk和XRead或XeRead，没有块选项，与任何其他KEYDB命令同步，
因此讨论这些命令的延迟是没有意义的：更有趣的是检查KEYDB文档中命令的时间复杂度。
可以说，在提取范围时，流命令的速度至少与已排序的set命令的速度一样快，而且XADD非常快，
如果使用流水线，可以很容易地在平均机器中每秒插入50万到100万个项。

但是，如果我们想了解处理消息的延迟，在阻塞消费者组中的消费者的上下文中，
从通过XADD生成消息的时刻到消费者获取消息的时刻（因为XREADGROUP返回了消息），延迟成为一个有趣的参数。

## 如何服务受阻的消费者

在提供已执行测试的结果之前，有兴趣了解KeyDB使用什么模型来路由流消息（以及通常如何管理等待数据的任何阻塞操作）。

* 阻塞的客户机在哈希表中被引用，哈希表将至少有一个阻塞使用者的key映射到正在等待此类key的使用者列表。
这样，给定一个接收数据的key，我们就可以解析所有等待此类数据的client。
* 当发生写操作时，在本例中，当调用XADD命令时，它将调用signalKeyAsReady() 函数。此函数将把key放入需要处理的key列表中，因为此类key可能会为使用者阻止新数据。
请注意，这样的就绪键将在稍后处理，因此在相同的事件循环过程中，该键可能会收到其他写入。
* 最后，在返回到事件循环之前，准备就绪的键最终被处理。对于每个key，运行等待数据的client列表，如果适用，这些client将接收到达的新数据。
在流的情况下，数据是消费者请求的适用范围内的消息。

## 延迟测试结果

为了检查这种延迟特性，我们使用多个Ruby程序实例执行了一个测试，这些Ruby程序将消息作为计算机毫秒时间的附加字段推送，
Ruby程序从消费者组读取消息并对其进行处理。消息处理步骤包括比较当前计算机时间和消息时间戳，以便了解总延迟。

这些程序没有经过优化，而是在一个运行KeyDB的小的双核实例中执行，以试图提供在非最佳条件下可能出现的延迟数字。
消息以每秒10k的速度生成，其中10个同时使用的用户消费并确认来自同一KeyDB流和使用组的消息。

获得的结果：

    Processed between 0 and 1 ms -> 74.11%
    Processed between 1 and 2 ms -> 25.80%
    Processed between 2 and 3 ms -> 0.06%
    Processed between 3 and 4 ms -> 0.01%
    Processed between 4 and 5 ms -> 0.02%

因此，99.9%的请求的延迟<=2毫秒，异常值仍然非常接近平均值。

在流中添加几百万条未确认的消息不会改变基准测试的要点，因为大多数查询仍然以很短的延迟进行处理。

几句话：

* 在这里，每次迭代最多处理10k条消息，这意味着XREADGROUP的COUNT参数设置为10000。
这会增加很多延迟，但为了让速度慢的消费者能够跟上消息流，这是必需的。所以你可以预期真实世界的延迟要小得多。

* 与今天的标准相比，用于这个基准的系统非常慢。

