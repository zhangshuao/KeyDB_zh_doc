# 事务

MULTI, EXEC, DISCARD 和 WATCH 是KeyDB事务的基础。
它们允许在一个步骤中执行一组命令，有两个重要的保证

事务中的所有命令都被序列化并按顺序执行。在执行KeyDB事务的过程中，决不能为另一个客户机发出的请求提供服务。
这保证了这些命令作为一个单独的操作执行。

要么处理所有命令，要么不处理任何命令，因此KeyDB事务也是原子的。EXEC命令触发执行事务中的所有命令，因此，如果客户端在调用MULTI命令之前失去了与事务上下文中服务器的连接，则不执行任何操作，
而如果调用EXEC命令，则执行所有操作。使用仅追加文件KeyDB时，请确保使用单个write(2)系统调用在磁盘上写入事务。
但是，如果KeyDB服务器崩溃或被系统管理员以某种方式终止，则可能只注册了部分操作。
KeyDB将在重新启动时检测此条件，并将退出一个错误。
使用keydb-check-aof工具，可以修复将删除部分事务的append-only文件，以便服务器可以重新启动。

从版本2.2开始，KeyDB以乐观锁定的形式为上述两个操作提供了额外的保证，其方式与check-and-set（CAS）操作非常相似。这将在本页后面记录。

## 使用

使用MULTI命令输入KeyDB事务。命令总是以"OK"回答。此时，用户可以发出多个命令。
KeyDB不会执行这些命令，而是将它们排队。所有的命令都在调用EXEC后执行。

相反，调用Debug将刷新事务队列并退出事务。

以下示例以原子方式递增键foo和bar。

    > MULTI
    OK
    > INCR foo
    QUEUED
    > INCR bar
    QUEUED
    > EXEC
    1) (integer) 1
    2) (integer) 1

从上面的会话中可以看到，EXEC返回一个应答数组，其中每个元素都是事务中单个命令的应答，其顺序与发出命令的顺序相同。

当KeyDB连接处于多个请求的上下文中时，所有命令都将使用排队的字符串进行应答（从KeyDB协议的角度来看，作为状态应答发送）。
队列命令只是在调用EXEC时安排执行。

## 事务中的错误

在事务处理期间，可能会遇到两种命令错误：

    * 命令可能无法排队，因此在调用EXEC之前可能有错误。
      例如，该命令可能语法错误（参数数目错误、命令名错误，…），或者可能存在一些关键条件，
      如内存不足条件（如果使用maxmemory指令将服务器配置为具有内存限制）。
    * 调用EXEC后，命令可能会失败，例如，因为我们对具有错误值的键执行了操作（例如对字符串值调用列表操作）。

client通常通过检查排队命令的返回值来检测在EXEC调用之前发生的第一类错误：如果命令使用queued应答，则它已正确排队，否则KeyDB将返回错误。
如果在命令排队时出现错误，大多数client将中止放弃该命令的事务。

但是，从KeyDB 2.6.5开始，服务器将记住在累积命令期间出现了错误，并且将拒绝执行事务，在EXEC期间返回错误并自动放弃事务。

在KeyDB 2.6.5之前，行为是在client调用EXEC时，仅使用排队成功的命令子集执行事务，而不考虑以前的错误。
新的行为使得将事务与管道混合变得更加简单，这样整个事务就可以一次发送，稍后一次读取所有回复。

在EXEC之后发生的错误不会以特殊的方式处理：即使某些命令在事务处理期间失败，也会执行所有其他命令。

这在协议层面上更为明确。在下面的示例中，即使语法正确，执行一个命令也会失败：

    Trying 127.0.0.1...
    Connected to localhost.
    Escape character is '^]'.
    MULTI
    +OK
    SET a 3
    abc
    +QUEUED
    LPOP a
    +QUEUED
    EXEC
    *2
    +OK
    -ERR Operation against a key holding the wrong kind of value

EXEC返回了两个元素@bulk string reply，其中一个是OK代码，另一个是-ERR回复。
这取决于client库找到一种合理的方法来向用户提供错误。

需要注意的是，即使一个命令失败，队列中的所有其他命令都会被处理–KeyDB不会停止命令的处理。

另一个示例（再次使用telnet的wire协议）显示了如何尽快报告语法错误：

    MULTI
    +OK
    INCR a b c
    -ERR wrong number of arguments for 'incr' command

这次由于语法错误，错误的INCR命令根本没有排队。

## 为什么KeyDB不支持回滚?

如果您有一个关系数据库背景，那么KeyDB命令在事务期间可能会失败，但KeyDB仍将执行事务的其余部分而不是回滚，这一事实在您看来可能有些奇怪。

不过，对于这种行为，有好的看法：

* 只有使用错误的语法调用KeyDB命令（并且在命令队列中无法检测到该问题）或针对持有错误数据类型的键调用KeyDB命令时，
  KeyDB命令才能失败：这意味着，实际上，失败的命令是编程错误的结果，也是开发过程中很可能检测到的一种错误，而不是在生产中。
* KeyDB在内部被简化，速度更快，因为它不需要回滚的能力。

反对KeyDB观点的一个论点是错误会发生，但是应该注意的是，一般情况下，回滚并不能使您避免编程错误。
例如，如果查询将键增加2而不是1，或者增加了错误的键，那么回滚机制就无法提供帮助。
考虑到没有人能将程序员从错误中拯救出来，并且KeyDB命令失败所需的那种错误不太可能进入生产环境，我们选择了不支持错误回滚的更简单、更快的方法。

## DISCARD 命令队列

DISCARD 可用于中止事务。在这种情况下，不执行任何命令，连接状态将恢复为正常。

    > SET foo 1
    OK
    > MULTI
    OK
    > INCR foo
    QUEUED
    > DISCARD
    OK
    > GET foo
    "1"

## 使用check-and-set的乐观锁定

WATCH用于为KeyDB事务提供check-and-set（CAS）行为。

监视的键被监视，以便检测对它们的更改。如果在EXEC命令之前至少修改了一个被监视的密钥，
则整个事务将中止，EXEC将返回@nil应答以通知事务失败。

例如，假设我们需要原子地将键的值增加1（假设KeyDB没有INCR）。

第一次尝试可能是：

    val = GET mykey
    val = val + 1
    SET mykey $val
    
只有当我们有一个client在给定的时间内执行操作时，这种方法才能可靠地工作。
如果多个client尝试同时增加key，则会出现竞争条件。例如，client A和B将读取旧值，例如10。两个client都会将该值递增到11，最后设置为key的值。
所以最终的值是11而不是12。

感谢WATCH，我们能够很好地模拟问题：

    WATCH mykey
    val = GET mykey
    val = val + 1
    MULTI
    SET mykey $val
    EXEC

使用上面的代码，如果在我们调用WATCH和调用EXEC之间存在竞争条件，并且另一个client修改val的结果，那么事务将失败。

我们只需要重复操作，希望这次不会有新的竞争。这种形式的锁定称为乐观锁定，是一种非常强大的锁定形式。
在许多用例中，多个client将访问不同的key，因此不太可能发生冲突-通常不需要重复该操作。

## WATCH 说明

那么WATCH到底是什么？这是一个使EXEC成为条件的命令：我们要求KeyDB只在监视的keydb没有被修改的情况下执行事务。
（但在事务内部，它们可能会被同一个client更改，而不会中止它。否则根本不输入事务记录。
（请注意，如果您看到一个易失性key，并且KeyDB在您看到该key后过期，EXEC仍将工作。

WATCH 可以调用多次。简单地说，从调用开始，直到调用EXEC时，所有的WATCH调用都将具有监视更改的效果。
你也可以发送任意数量的key到一个WATCH 调用。

调用EXEC时，无论事务是否中止，所有key都是不匹配的。同时，当client连接关闭时，一切都将变得不匹配。

也可以使用UNWATCH命令（不带参数）刷新所有被监视的key。有时这很有用，因为我们可以乐观地锁定一些key，
因为我们可能需要执行一个事务来更改这些key，但是在读取了key的当前内容之后，我们不想继续。
当这种情况发生时，我们只调用UNWATCH，这样连接就可以自由地用于新的事务。


### 使用 WATCH 去实现 ZPOP

一个很好的例子来说明如何使用WATCH创建新的原子操作，否则KeyDB不支持这个操作，这个例子就是实现ZPOP，
这是一个命令，它以原子的方式从排序集中弹出得分较低的元素。这是最简单的实现：

    WATCH zset
    element = ZRANGE zset 0 0
    MULTI
    ZREM zset element
    EXEC

如果EXEC失败（即返回@nil-reply），我们只需重复该操作。

## KeyDB脚本和事务

根据定义，KeyDB脚本是事务性的，因此您可以使用KeyDB事务执行任何操作，
也可以使用脚本执行任何操作，而且通常脚本会更简单、更快。

这种复制是由于在key数据库2.6中引入了脚本，而事务早就存在了。
然而，我们不太可能在短时间内删除对事务的支持，因为它看起来在语义上是恰巧的，即使不使用KEYDB脚本，它仍然可以避免竞争条件，
尤其是因为key数据库事务的实现复杂性是最小的。

然而，在不久的将来，我们将看到整个用户群只是在使用脚本，这并非不可能。
如果发生这种情况，我们可能会拒绝并最终删除事务。

