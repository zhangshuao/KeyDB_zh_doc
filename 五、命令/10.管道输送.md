# 使用Pipeling管道加速查询

## 请求/响应协议 和 RTT

KeyDB是一个使用 client-server 模型和所谓的请求/响应协议的TCP服务器。

这意味着请求通常通过以下步骤完成：

客户机向服务器发送一个查询，并从套接字读取服务器响应，通常是以阻塞的方式。

服务器处理命令并将响应发送回客户端。

例如，四个命令的顺序如下：

    Client: INCR X
    Server: 1
    Client: INCR X
    Server: 2
    Client: INCR X
    Server: 3
    Client: INCR X
    Server: 4

客户端和服务器通过网络连接。这样的链接可以是非常快（环回接口）或非常慢（在Internet上建立的连接，两台主机之间有许多跳）。
无论网络延迟是什么，数据包都有一段时间从客户机传输到服务器，然后从服务器返回到客户机以携带应答。

这个时间叫做RTT（往返时间）。当客户机需要在一行中执行多个请求时（例如向同一列表中添加多个元素，或用多个键填充数据库），
很容易看出这会如何影响性能。例如，如果RTT时间是250毫秒（在Internet上的链接非常慢的情况下），
即使服务器能够每秒处理10万个请求，我们也能够每秒最多处理4个请求。

如果使用的接口是环回接口，则RTT要短得多（例如，我的主机报告0,044毫秒ping 127.0.0.1），
但如果需要连续执行许多写操作，则RTT仍然很短。

幸运的是，有一种方法可以改进这个用例。

## KeyDB Pipelining

可以实现请求/响应服务器，以便它能够处理新的请求，即使客户端尚未读取旧的响应。
这样就可以向服务器发送多个命令，而无需等待回复，最后只需一步就可以读取回复。

这被称为流水线，是几十年来广泛使用的一种技术。例如，许多POP3协议实现已经支持此功能，大大加快了从服务器下载新电子邮件的过程。

KeyDB从早期就支持流水线，因此无论运行什么版本，都可以将流水线与KeyDB一起使用。
下面是使用原始netcat实用程序的示例：

    $ (printf "PING\r\nPING\r\nPING\r\n"; sleep 1) | nc localhost 6379
    +PONG
    +PONG
    +PONG

这一次我们不是为每个调用支付RTT成本，而是为三个命令支付一次。

非常明确地说，通过流水线，我们的第一个示例的操作顺序如下：

    * Client: INCR X
    * Client: INCR X
    * Client: INCR X
    * Client: INCR X
    * Server: 1
    * Server: 2
    * Server: 3
    * Server: 4

**重要提示：** 当客户端使用管道发送命令时，服务器将被迫使用内存对回复进行排队。
因此，如果需要使用管道发送大量命令，最好将它们作为具有合理数量的批发送，例如10k个命令，读取回复，然后再次发送10k个命令，以此类推。
速度将几乎相同，但所用的额外内存将达到将此10k命令的响应排队所需的最大数量。

## 这不仅仅是RTT的问题

流水线不仅仅是为了减少由于往返时间而造成的延迟成本，它实际上大大提高了在给定KeyDB服务器中每秒可以执行的操作总数。
这是因为，在不使用流水线的情况下，从访问数据结构和生成应答的角度来看，为每个命令提供服务是非常便宜的，但从执行套接字I/O的角度来看，代价是非常昂贵的。
这包括调用read() 和write()系统调用，这意味着从用户端到内核端。上下文切换是一个巨大的速度惩罚。

当使用流水线时，许多命令通常用一个read() 系统调用读取，而多个应答则用一个write()系统调用传递。
因此，每秒执行的查询总数最初几乎与较长的管道成线性增长，最终达到不使用管道的基线的10倍

## Pipelining 与 脚本

使用KeyDB脚本(eval)（KeyDB 2.6版或更高版本中提供）可以使用在服务器端执行大量所需工作的脚本更有效地解决许多用于管道的用例。
脚本的一大优点是它能够以最小的延迟同时读取和写入数据，使得读取、计算、写入等操作变得非常快（在这种情况下，流水线无法提供帮助，因为客户端需要在调用write命令之前得到read命令的回复）。

有时应用程序可能还希望在管道中发送EVAL或EVALSHA命令。
这是完全可能的，KeyDB通过脚本加载命令显式地支持它（它保证可以调用EVALSHA而不会有失败的风险）。

## 附录：为什么繁忙的循环即使在环回接口上也很慢？

即使本页介绍了所有背景，您仍然可能会想知道，当服务器和客户机运行在同一台物理机上时，
即使在环回接口中执行KeyDB基准测试（以伪代码表示）时，为什么速度慢：

    FOR-ONE-SECOND:
        keydb.SET("foo","bar")
    END

毕竟，如果KeyDB进程和基准测试都在同一个框中运行，难道这不只是通过内存从一个地方复制到另一个地方的消息，
而不涉及任何实际的延迟和实际的网络吗？

原因是系统中的进程并不总是在运行，实际上是内核调度器让进程运行，所以发生的情况是，
例如，基准测试被允许运行，从KeyDB服务器读取应答（与最后执行的命令相关），并写入一个新命令。
该命令现在位于环回接口缓冲区中，但是为了让服务器读取，内核应该安排服务器进程（当前在系统调用中被阻止）运行，以此类推。
因此，实际上，由于内核调度器的工作方式，环回接口仍然涉及类似网络的延迟。

基本上，当测量网络服务器的性能时，繁忙循环基准测试是最愚蠢的事情。明智的做法是这样避免基准测试。
