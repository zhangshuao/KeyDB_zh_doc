# 使用KeyDB作为LRU缓存

当KeyDB用作缓存时，通常在添加新数据时让它自动收回旧数据是很方便的。这种行为在开发人员社区中非常有名，因为它是流行的memcached系统的默认行为。

LRU实际上只是支持的逐出方法之一。本页涵盖了用于限制内存使用到固定量的KeyDB maxmemory指令的更一般的主题，
并且它还深入地描述了KeyDB所使用的LRU算法，这实际上是精确的LRU的近似值。

从KeyDB version 4.0开始，引入了一个新的LFU（最不常用的）逐出策略。这将在本文档的一个单独部分中介绍。

## maxmemory配置指令

maxmemory配置指令用于将KeyDB配置为使用数据集的指定内存量。
可以使用redis.conf文件设置配置指令，或者在运行时使用CONFIG set命令设置配置指令。

例如，为了配置100兆字节的内存限制，可以在redis.conf文件中使用以下指令:

    maxmemory 100mb

将maxmemory设置为零将导致没有内存限制。这是64位系统的默认行为，而32位系统使用3GB的隐式内存限制。

当达到指定的内存量时，可以在不同的行为（称为策略）中进行选择。KeyDB可以只返回可能导致使用更多内存的命令的错误，
也可以逐出一些旧数据，以便在每次添加新数据时返回到指定的限制。

## 驱逐政策

当使用maxmemory policy configuration指令配置达到maxmemory限制时，KeyDB将遵循确切的行为。

以下策略可用：

* noeviction：当达到内存限制并且客户端试图执行可能导致使用更多内存的命令（大多数写命令，但DEL和一些其他异常）时返回错误。
* allkeys-lru：首先尝试删除最近使用较少的（lru）keys，以便为添加的新数据腾出空间，从而逐出keys。
* volatile-lru：通过尝试首先删除最近使用较少的（lru）keys来逐出keys，但只能在具有expire集的key中删除，以便为添加的新数据腾出空间。
* allkeys-random：随机收回keys，以便为添加的新数据腾出空间。
* volatile-random：随机收回keys，以便为添加的新数据腾出空间，但仅收回具有expire集的keys。
* volatile-ttl：使用expire集收回keys，并尝试首先收回生存时间较短（ttl）的key，以便为添加的新数据腾出空间。

策略volatile-lru、volatile-random和volatile-ttl的行为类似于noeviction（如果没有匹配先决条件的逐出key）。

根据应用程序的访问模式，选择正确的逐出策略非常重要，但是您可以在应用程序运行时重新配置该策略，
并使用KeyDB INFO输出监视缓存未命中和命中数，以便优化设置。

一般来说，作为经验法则：

* 当您希望请求的流行程度达到幂律分布时，使用allkeys-lru策略，也就是说，您希望元素的子集比其他元素的访问频率要高得多。
如果你不确定的话，这是个不错的选择。

* 如果您有一个循环访问，其中所有key都被连续扫描，或者当您希望分布是一致的（所有可能以相同概率访问的元素）时，请使用allkeys-random。

* 如果您想在创建缓存对象时使用不同的ttl值向KeyDB提供有关哪些内容适合过期的提示，请使用volatile-ttl。

volatile-lru和volatile-random策略主要用于希望将单个实例同时用于缓存和拥有一组持久key的情况。
不过，通常最好运行两个KeyDB实例来解决此问题。

还值得注意的是，设置key过期会消耗内存，因此使用allkeys-lru这样的策略更节省内存，因为在内存压力下不需要设置key的过期。

## 驱逐程序的工作原理

重要的是要了解驱逐过程的工作方式如下：

* 客户端运行一个新命令，从而添加更多数据。
* KeyDB检查内存使用情况，如果大于maxmemory限制，则根据策略收回key。
* 执行一个新命令，依此类推。

所以我们不断地越过内存限制的边界，越过它，然后逐出key返回到限制之下。

如果一个命令在一段时间内导致大量内存被使用（如存储到新key中的一个大集合交集），那么内存限制可能会被明显超过。

## 近似LRU算法

KeyDB LRU算法不是一个精确的实现。这意味着KeyDB无法选择最佳的逐出候选，即过去访问最多的访问。
相反，它将尝试运行LRU算法的近似，通过采样少量的key，并在采样key之间删除最好的（具有最长的访问时间）。


然而，自从KeyDB 3.0之后，该算法得到了改进，同时也获得了一个很好的候选驱逐池。
这改进了算法的性能，使得它能够更接近地逼近真实LRU算法的行为。

KeyDB LRU算法的重要之处在于，您可以通过更改采样数来调整算法的精度，以检查每次逐出。此参数由以下配置指令控制：

    maxmemory-samples 5

KeyDB不使用真正的LRU实现的原因是它需要更多的内存。然而，对于使用KEYDB的应用来说，近似实际上是等价的。
下面是KEYDB所使用的LRU近似与真实LRU的图形比较。

LRU比较

生成上述图的测试使用给定数量的key填充KeyDB服务器。key是从第一个到最后一个访问的，因此第一个key是使用LRU算法驱逐的最佳候选key。
之后，添加了50%以上的key，以强制收回一半的旧key。

你可以在图中看到三种点，形成三个不同的带。

* 浅灰色带是被逐出的对象。
* 灰色带是未被逐出的对象。
* 绿色带是添加的对象。

在一个理论上的LRU实现中，我们期望在旧key中，前半个key将过期。KeyDB LRU算法将只在概率上使旧key过期。

正如您所看到的，与KeyDB 2.8相比，KeyDB 3.0在5个示例上做得更好，但是大多数最新访问的对象仍然由keydb2.8保留。
使用KEYDB 3中的10的样本大小，近似非常接近KEYDB 3的理论性能。

请注意，LRU只是一个模型，用于预测将来访问给定key的可能性。
此外，如果您的数据访问模式非常类似幂律，那么大部分访问将在LRU近似算法能够处理的key集合中。

在模拟中，我们发现，使用幂律访问模式，真正的LRU和KEYDB近似之间的差异是最小的或不存在的。

但是，可以以额外的CPU使用率将样本量提高到10，以便接近真实的LRU，并检查这是否对缓存命中率产生了影响。

使用CONFIG SET maxmemory-samples <count>命令在生产环境中使用不同的样本大小值进行实验非常简单。

## 新的LFU模式

从KeyDB 4.0开始，一个新的最不常用的逐出模式可用。在某些情况下，此模式可能会更好地工作（提供更好的命中/未命中率），因为使用LFU KeyDB将尝试跟踪项的访问频率，以便很少使用的项被逐出，
而使用的项通常有更高的机会留在内存中。

如果您认为在LRU，一个最近访问过但实际上几乎从未被请求过的项不会过期，那么风险是收回一个在将来被请求的机会更高的key。LFU不存在这个问题，通常应该更好地适应不同的访问模式。

要配置LFU模式，可以使用以下策略：

* volatile-lfu 使用具有到期集的key中使用近似的LFU。
* volatile-lfu 使用近似的LFU删除任何key。

LFU近似于LRU：它使用一个概率计数器，称为Morris计数器，以估计每个对象只使用几比特的对象访问频率，
结合衰变周期，使得计数器随着时间的推移而减少：在某个时刻，即使在过去，我们也不再想考虑频繁访问的key，使算法能够适应访问模式的变化。

这些信息的采样与LRU的情况类似（如本文档前一节所述），以便选择要驱逐的候选者。

然而，与LRU不同的是，LFU具有某些可调参数：例如，如果一个频繁项不再被访问，那么它应该以多快的速度降低其排名？
也可以调整Morris计数器的范围，以便更好地使算法适应特定的用例。

默认情况下，KeyDB 4.0配置为：

* 在大约一百万个请求时使计数器饱和。
* 每隔一分钟腐蚀一次计数器。

这些值应该是合理的，并且是经过实验测试的，但是用户可能希望使用这些配置设置来选择最佳值。

有关如何优化这些参数的说明可以在源发行版中的示例redis.conf文件中找到，但简单地说，它们是：

    lfu-log-factor 10
    lfu-decay-time 1

衰减时间是最明显的一个，它是一个计数器应衰减的分钟数，当采样并发现比该值旧。
特殊值为0意味着：每次扫描都会衰减计数器，而且很少有用。

计数器对数因子改变需要多少次点击才能使频率计数器饱和，频率计数器刚好在0-255范围内。
因子越高，则需要越多的访问才能达到最大值。根据下表，因子越低，计数器对于低访问的分辨率越好：

    +--------+------------+------------+------------+------------+------------+
    | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
    +--------+------------+------------+------------+------------+------------+
    | 0      | 104        | 255        | 255        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 1      | 18         | 49         | 255        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 10     | 10         | 18         | 142        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 100    | 8          | 11         | 49         | 143        | 255        |
    +--------+------------+------------+------------+------------+------------+

因此，基本上，这个因素是在更好地区分低访问权限的项与区分高访问权限的项之间进行权衡。
更多信息可以在示例redis.conf文件自文档注释中找到。

由于LFU是一个新特性，我们将非常感谢与LRU相比关于它在您的用例中如何执行的任何反馈。
