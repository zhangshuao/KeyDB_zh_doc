# 持久化

KeyDB提供了一系列不同的持久性选项：

    * RDB持久性以指定的间隔执行数据集的时间点快照。
    * AOF持久性记录服务器接收到的每个写操作，这些操作将在服务器启动时再次播放，从而重建原始数据集。
    命令使用与KeyDB协议本身相同的格式进行记录，采用仅附加的方式。当日志太大时，KeyDB能够在后台重写日志。
    * 如果您希望，如果您希望只要服务器运行，您的数据就存在，就可以禁用持久性。
    * 可以在同一个实例中同时使用AOF和RDB。注意，在这种情况下，当KeyDB重新启动时，AOF文件将用于重建原始数据集，
    因为它保证是最完整的。

最重要的是理解RDB和AOF持久性之间的不同权衡。让我们从RDB开始：

## RDB 优势

* RDB是KeyDB数据的非常紧凑的单文件时间点表示。RDB文件非常适合备份。
例如，您可能希望在最近的24小时内每小时存档一次RDB文件，并在30天内每天保存一个RDB快照。这允许您在发生灾难时轻松恢复数据集的不同版本。
* RDB对于灾难恢复非常有用，因为一个压缩文件可以传输到远端数据中心，或者在Amazon S3上（可能是加密的）。
* RDB最大化了KeyDB性能，因为KeyDB父进程需要做的唯一工作就是坚持一个将完成所有剩余的孩子。父实例永远不会执行磁盘I/O或类似的操作。
* 与AOF相比，RDB允许使用大数据集更快地重新启动。

## RDB 劣势

* 如果您需要在KeyDB停止工作时（例如断电后）将数据丢失的机会降到最低，那么RDB就不好。
您可以在生成RDB的地方配置不同的保存点（例如，至少在对数据集进行5分钟和100次写入之后，但是您可以有多个保存点）。
但是，您通常会每五分钟或更长时间创建一个RDB快照，因此，如果KeyDB由于任何原因在没有正确关机的情况下停止工作，您应该准备好丢失最新几分钟的数据。

* RDB需要经常fork()，以便使用子进程在磁盘上持久化。如果数据集很大，Fork()可能会很耗时，如果数据集很大，CPU性能不好，KeyDB可能会在几毫秒甚至一秒钟内停止为客户端提供服务。
AOF还需要fork()，但您可以调整重写日志的频率，而不必在持久性上做任何权衡。

## AOF 优势

* 使用AOF KeyDB要持久得多：您可以有不同的fsync策略：根本无 fsync，每秒fsync，每次查询fsync。
使用fsync的默认策略，每秒的写入性能仍然很好（fsync是使用后台线程执行的，当没有fsync进行时，主线程将努力执行写入操作）。
但是您只能丢失一秒钟的写入操作。

* AOF日志是一个只附加的日志，因此在断电的情况下不会出现查找或损坏问题。
即使日志由于某种原因（磁盘已满或其他原因）以半写命令结束，keydb-check-aof工具也能够轻松地修复它。

* KeyDB能够在后台自动重写AOF，当它变得太大时。重写是完全安全的，因为当KeyDB继续追加到旧文件时，将生成一个完全新的文件，只需创建当前数据集所需的最小操作集，并且一旦第二个文件就绪，KeyDB将切换这两个文件并开始追加到新文件。

* aof以易于理解和解析的格式一个接一个地包含所有操作的日志。甚至可以轻松导出AOF文件。
例如，即使您使用FLUSHALL命令刷新了所有错误的内容，但如果在此期间没有执行日志重写，您仍然可以保存数据集，
只需停止服务器，删除最新命令，然后重新启动KeyDB。

## AOF 劣势

AOF文件通常比相同数据集的等效RDB文件大。

AOF可能比RDB慢，具体取决于fsync策略。一般来说，fsync设置为每秒一次时，性能仍然非常高，
而禁用fsync时，即使在高负载下，它也应该与RDB一样快。RDB仍然能够提供最大延迟的更多保证，即使在巨大的写入负载的情况下也是如此。

在过去，我们在特定命令中遇到了一些罕见的错误（例如，有一个错误涉及BRPOPLPUSH之类的阻塞命令），
导致生成的AOF在重新加载时不能完全复制相同的数据集。这种错误很少见，我们在测试套件中有测试自动创建随机的复杂数据集并重新加载它们以检查一切正常，
但是这种错误在RDB持久性中几乎是不可能的。为了使这一点更清楚：KEYDB AOF工作增量更新现有状态，比如MySQL或MongoDB，而RDB快照从一次又一次从头开始创建一切，这在概念上更健壮。然而-

i. 应该注意的是，每次KeyDB重写AOF时，它都是从头开始重新创建的，从数据集中包含的实际数据开始，
与总是附加AOF文件（或一个重写读取旧AOF而不是读取内存中的数据）相比，它增强了对错误的抵抗力。

ii. 我们从来没有收到过用户关于AOF在现实世界中被检测到的损坏的报告。

## 好吧，那我该用什么呢？

一般情况下，如果希望获得与PostgreSQL相当的数据安全性，应该同时使用这两种持久性方法。

如果您非常关心自己的数据，但在发生灾难时仍然可以忍受几分钟的数据丢失，那么您只需使用RDB即可。

有许多用户单独使用aof，但我们不鼓励这样做，因为不时地使用RDB快照是进行数据库备份、更快地重新启动以及在AOF引擎出现错误时的一个好主意。

注意：由于所有这些原因，我们很可能在将来将AOF和RDB统一为一个持久性模型（长期计划）。

以下各节将详细介绍这两个持久性模型。

## 快照

默认情况下，KeyDB将数据集的快照保存在磁盘上名为dump.rdb的二进制文件中。
如果数据集中至少有M个更改，可以将KeyDB配置为让它每隔N秒保存一次数据集，也可以手动调用save或BGSAVE命令。

例如，如果至少更改了1000个key，此配置将使KeyDB每隔60秒自动将数据集转储到磁盘：

    save 60 1000

这种策略被称为快照。

### 他如何工作

每当KeyDB需要将数据集转储到磁盘时，都会发生以下情况：

* KeyDB fork。我们现在有一个子进程和一个父进程。

* 子对象开始将数据集写入临时RDB文件。

* 当孩子完成新的RDB文件的编写时，它将替换旧的RDB文件。

此方法允许KeyDB受益于copy-on-write语义

## 仅追加文件

快照不是很耐用。如果运行KeyDB的计算机停止运行，电源线出现故障，或者意外地kill -9实例，则KeyDB上写入的最新数据将丢失。
虽然这对某些应用程序来说可能不是什么大问题，但是有一些用例是完全持久的，在这些情况下KeyDB不是一个可行的选择。

append-only文件是KeyDB的一种替代的、完全持久的策略。它在版本1.1中可用。

您可以在配置文件中打开AOF：

    appendonly yes

从现在起，每当KeyDB接收到更改数据集（例如SET）的命令时，它都会将其附加到AOF中。
重新启动KeyDB时，它将re-play AOF以重建状态。

### 日志写入

如您所料，AOF随着写操作的执行而变得越来越大。
例如，如果您将一个计数器递增100次，那么您的数据集中只会有一个key包含最终值，而AOF中只有100个条目。其中99个条目不需要重建当前状态。

因此KeyDB支持一个有趣的特性：它能够在后台重建AOF，而不会中断对客户机的服务。
每当您发出BGREWRITEAOF KeyDB时，它将写入重建内存中当前数据集所需的最短命令序列。
如果使用KeyDB 2.2的AOF，则需要不时运行BGREWRITEAOF。KeyDB 2.4能够自动触发日志重写（有关更多信息，请参阅2.4示例配置文件）。

### 仅追加文件的持久性如何？

您可以配置KeyDB在磁盘上fsync数据的次数。有三种选择：

* appendfsync always: fsync每次向AOF追加新命令时。非常慢，非常安全。

* appendfsync everysec:每秒钟一次. 足够快（在2.4中可能和快照一样快），如果发生灾难，您可能会丢失1秒的数据。

* appendfsync no ：永远不要fsync，把你的数据放在操作系统的手里。更快更不安全的方法。
通常Linux会每隔30秒用这个配置刷新一次数据，但这取决于内核的精确调优。

建议（default）策略是每秒fsync一次。它既快又安全。
always策略在实践中非常慢，但它支持组提交，因此如果有多个并行写入，KeyDB将尝试执行一个fsync操作。

### 如果我的AOF被截断，我该怎么办？

可能是服务器在写入AOF文件时崩溃，或者存储AOF文件的卷已满。
当这种情况发生时，aof仍然包含表示给定时间点版本的数据集的一致数据（使用默认AOF fsync策略，该数据集可能最长为1秒），
但AOF中的最后一个命令可能会被截断。KeyDB的最新主要版本无论如何都可以加载AOF，只需丢弃文件中最后一个格式不正确的命令。
在这种情况下，服务器将发出如下日志：

    * Reading RDB preamble from AOF file...
    * Reading the remaining AOF tail...
    # !!! Warning: short read while loading the AOF file !!!
    # !!! Truncating the AOF at offset 439 !!!
    # AOF loaded anyway because aof-load-truncated is enabled

如果需要，可以更改默认配置以强制KeyDB在这种情况下停止，但默认配置是继续，
而不管文件中最后一个命令的格式是否正确，以确保重新启动后可用。

旧版本的KeyDB可能无法恢复，可能需要以下步骤：

* 备份你的aof文件。
* 使用keydb附带的keydb-check-aof工具修复原始文件：

    $ keydb-check-aof --fix <filename>

* 可以选择使用diff -u来检查两个文件之间的区别。
* 用不变文件重新启动服务器。

### 如果我的AOF被破坏了我该怎么办？

如果AOF文件不只是被截断，而是被中间的无效字节序列损坏，事情就更复杂了。
KeyDB将在启动时投诉并中止：

    * Reading the remaining AOF tail...
    # Bad file format reading the append only file: make a backup of your AOF file, then use ./keydb-check-aof --fix <filename>

最好的做法是运行keydb-check-aof实用程序，最初没有--fix选项，然后理解问题，跳转到文件中给定的偏移量，
看看是否可以手动修复文件：aof使用与keydb协议相同的格式，手动修复非常简单。
否则，可以让实用程序为我们修复该文件，但在这种情况下，从无效部分到文件结尾的所有aof部分都可能被释放，如果损坏发生在文件的初始部分，
则会导致大量数据丢失。

### 他如何工作

日志重写使用的是已用于快照的同一写时复制技巧。这就是它的工作原理：

* KeyDB forks, 所以现在我们有一个子进程和一个父进程。

* 子进程开始在临时文件中写入新的AOF。

* 父进程在内存缓冲区中累积所有新更改（但同时将新更改写入旧的append-only文件，因此如果重写失败，我们是安全的）。

* 当子进程重写完成后，父进程会收到一个信号，并在子进程生成的文件末尾附加内存缓冲区。

* 收益！现在KeyDB原子地将旧文件重命名为新文件，并开始将新数据追加到新文件中。

### 如果我当前正在使用dump.rdb快照，如何切换到AOF？

在KeyDB 2.0和keydb2.2中有一个不同的过程来完成此操作，您可以猜到keydb2.2中的过程更简单，根本不需要重新启动。

**KeyDB >= 2.2**

* 备份最新的dump.rdb文件。
* 把这个备份转移到一个安全的地方。
* 发出以下两个命令：
* keydb-cli config set appendonly yes
* keydb-cli config set save ""
* 确保您的数据库包含的密钥数与其包含的密钥数相同。
* 确保正确地将写操作附加到仅附加文件。

第一个CONFIG命令启用仅追加文件。为此，KeyDB将阻塞以生成初始转储，然后将打开文件进行写入，并开始追加所有下一个写入查询。

第二个CONFIG命令用于关闭快照持久性。这是可选的，如果您希望同时启用这两种持久性方法。

**重要提示：** 请记住编辑KeyDB.conf以打开AOF，否则重新启动服务器时，配置更改将丢失，服务器将使用旧配置重新启动。

**KeyDB 2.0**

* 备份最新的dump.rdb文件。
* 把这个备份转移到一个安全的地方。
* 停止对数据库的所有写操作！
* 发出keydb-cli bgrewriteaof。这将创建仅追加文件。
* KeyDB完成生成AOF转储时停止服务器。
* 编辑keydb.conf 启用append only持久性。
* 重新启动服务器。
* 确保您的数据库包含的密钥数与其包含的密钥数相同。
* 确保正确地将写操作附加到仅附加文件。

## AOF和RDB持久性之间的交互

KeyDB>=2.4确保在RDB快照操作已经在进行时避免触发AOF重写，或者在AOF重写正在进行时允许BGSAVE。
这可以防止两个KeyDB后台进程同时执行大量磁盘I/O。

当快照正在进行中，并且用户显式地使用bgrewriteao请求日志重写操作时，如果服务器将用OK状态代码回复，
告诉用户该操作已计划好，则快照完成后将开始重写。

在同时启用AOF和RDB持久性和KeyDB重新启动的情况下，AOF文件将用于重建原始数据集，因为它保证是最完整的。

## 备份 KeyDB 数据

在开始本节之前，请确保阅读以下句子：确保备份数据库。磁盘中断、云中的实例消失等等：
没有备份意味着数据消失到/dev/null中的巨大风险。

KeyDB对数据备份非常友好，因为您可以在数据库运行时复制RDB文件：RDB一旦生成就不会被修改，而在生成时，它使用一个临时名称，并且仅在新快照完成时才使用rename(2) 原子地重命名为其最终目标。

这意味着在服务器运行时复制RDB文件是完全安全的。这是我们的建议：

* 在服务器中创建cron作业，在一个目录中创建RDB文件的每小时快照，在另一个目录中创建每日快照。

* 每次运行cron脚本时，请确保调用find命令以确保删除太旧的快照：
例如，您可以在最近48小时内拍摄每小时快照，在一到两个月内拍摄每日快照。请确保使用数据和时间信息命名快照。

* 每天至少一次确保在数据中心外或运行KeyDB实例的物理计算机外传输RDB快照。

如果只在启用AOF持久性的情况下运行KeyDB实例，则仍然可以复制AOF以创建备份。
文件可能缺少最后一部分，但是KeyDB仍然能够加载它（请参阅前面关于截断的AOF文件的部分）。

## 灾难恢复

KeyDB上下文中的灾难恢复与备份基本相同，而且能够在许多不同的外部数据中心中传输这些备份。
这样即使在某些灾难性事件影响KeyDB正在运行并生成其快照的主数据中心时，也可以保护数据。

由于许多KeyDB用户都在启动场景中，因此没有足够的钱花，我们将回顾最有趣的灾难恢复技术，这些技术没有太高的成本。

* Amazon S3和其他类似的服务是实现灾难恢复系统的好方法。只需将每日或每小时的RDB快照以加密的形式传输到S3。
您可以使用gpg -c（在对称加密模式下）加密数据。请确保将密码存储在许多不同的安全位置（例如，向组织中最重要的人提供一份副本）。
建议使用多个存储服务以提高数据安全性。

* 使用SCP（SSH的一部分）将快照传输到远端服务器。这是一个相当简单和安全的路径：在离您很远的地方获取一个小VPS，在那里安装ssh，生成一个不带密码短语的ssh客户端key，
然后将其添加到您的小VPS的authorized_keys文件中。您已准备好以自动方式传输备份。在两个不同的提供商中获得至少两个VP以获得最佳结果。

重要的是要明白，如果不以正确的方式实现，这个系统很容易失败。
至少要确保传输完成后，您能够验证文件大小（应该与复制的文件匹配），如果您使用的是VPS，还可以验证SHA1摘要。

如果由于某种原因新备份的传输不起作用，您还需要某种独立的警报系统。
    