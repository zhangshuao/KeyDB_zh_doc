# 数据类型 

## Strings

字符串是最基本的KeyDB值。KeyDB字符串是二进制安全的，
这意味着KeyDB字符串可以包含任何类型的数据，例如JPEG图像或序列化的Ruby对象。

字符串值的最大长度为512M字节。

您可以使用KeyDB中的字符串执行许多有趣的操作，例如，您可以：

* 使用INCR系列中的命令INCR、decre、INCRBY将字符串用作原子计数器。
* 使用Append命令追加到字符串。
* 使用字符串作为带有GETRANGE和SETRANGE的随机访问向量。
* 在小空间中编码大量数据，或者使用GETBIT和SETBIT创建KeyDB支持的Bloom过滤器。

有关详细信息，请检查所有可用的字符串命令，或阅读KeyDB数据类型简介

## Lists

KeyDB列表只是按插入顺序排序的字符串列表。可以将元素添加到KeyDB列表，将新元素推到列表的头部（左侧）或尾部（右侧）。

LPUSH命令在头部插入新元素，RPUSH在尾部插入新元素。
当对空键执行其中一个操作时，将创建一个新列表。类似地，如果列表操作将清空列表，则从键空间中移除键。
这些都是非常方便的语义，因为所有列表命令的行为与调用一个空列表一样准确，如果用非存在的键作为参数调用。

列表操作和结果列表的一些示例：

    LPUSH mylist a   # now the list is "a"
    LPUSH mylist b   # now the list is "b","a"
    RPUSH mylist c   # now the list is "b","a","c" (RPUSH was used this time)

列表的最大长度是2^32-1个元素（4294967295，每个列表超过40亿个元素）。

从时间复杂度的角度来看，KEYDB列表的主要特征是支持恒定时间插入和删除头部和尾部附近的元素，甚至有数百万个插入项。
访问元素的速度非常快，接近列表的极限，但如果尝试访问非常大的列表的中间，则速度会很慢，因为这是一个O（N）操作。

你可以用KeyDB列表做很多有趣的事情，例如你可以：

* 在社交网络中建立时间线模型，使用LPUSH在用户时间线中添加新元素，使用LRANGE检索最近插入的项目。
* 可以使用LPUSH和LTRIM创建一个列表，该列表永远不会超过给定数量的元素，而只记住最新的N个元素。
* 列表可以用作消息传递原语，例如，请参见众所周知的用于创建后台作业的Resque Ruby库。
* 你可以用列表做更多的事情，这个数据类型支持很多命令，包括像BLPOP这样的阻塞命令。

有关详细信息，请检查列表中所有可用的命令，或阅读KeyDB数据类型介绍。

## Sets

KeyDB集合是字符串的无序集合。可以在O（1）中添加、删除和测试成员的存在（不管集合中包含的元素的数量不变的时间）。

KeyDB集具有不允许重复成员的理想特性。多次添加同一个元素将导致一个集合具有此元素的单个副本。
实际上，这意味着添加成员不需要检查，如果存在，则添加操作。

KEYDB集非常有趣的一点是，它们支持许多服务器端命令来计算从现有集合开始的集合，
因此可以在很短的时间内完成集合、交叉点、集合的差异。

一组成员的最大数目是2^32-1（4294967295，每组超过40亿个成员）。

您可以使用KeyDB集执行许多有趣的操作，例如：

* 您可以使用KeyDB集跟踪独特的内容。想知道访问给定博客文章的所有唯一IP地址吗？
只需在每次处理页面视图时使用SADD。您确定不会插入重复的IP。
* KeyDB集很好地表示关系。您可以使用KeyDB创建一个标记系统，使用一个集合来表示每个标记。
然后，可以使用SADD命令将具有给定标记的所有对象的所有id添加到表示该特定标记的集合中。
是否希望所有对象的所有IDs同时具有三个不同的标记？就用SINTER。
* 可以使用集合使用SPOP或SRANDMEMBER命令随机提取元素。

与往常一样，查看Set命令的完整列表以获取更多信息，或者阅读KeyDB数据类型的介绍。

## Hashes

KeyDB散列是字符串字段和字符串值之间的映射，因此它们是表示对象的理想数据类型（例如，具有许多字段的用户，如名称、姓氏、年龄等）：

    @cli
    HMSET user:1000 username john password P1pp0 age 34
    HGETALL user:1000
    HSET user:1000 password 12345
    HGETALL user:1000

一个包含几个字段的散列（其中很少的字段表示多达100个左右）以占用很少空间的方式存储，
因此您可以在一个小型KeyDB实例中存储数百万个对象。

虽然散列主要用于表示对象，但它们能够存储许多元素，因此您也可以将散列用于许多其他任务。

每个散列最多可以存储2^32-1个字段值对（超过40亿）。

有关详细信息，请查看哈希命令的完整列表，或阅读KeyDB数据类型介绍。

## Sorted sets

KeyDB排序集与KeyDB集类似，是字符串的非重复集合。
不同之处在于，排序集的每个成员都与score关联，score用于将排序集从最小的score排序到最大的score。
虽然成员是唯一的，但分数可以重复。

使用排序集，您可以非常快速地添加、删除或更新元素（时间与元素数的对数成正比）。
由于元素是按顺序排列的，而不是按顺序排列的，所以您也可以很快地按分数或等级（位置）获得范围。
访问排序集的中间也是非常快的，因此您可以使用排序的集合作为非重复元素的智能列表，
您可以快速地访问所需的所有元素：顺序元素、快速存在测试、快速访问中间元素；

简而言之，使用排序集，您可以执行许多性能卓越的任务，而这些任务在其他类型的数据库中很难建模。

通过排序集，您可以：

* 在一个大型的在线游戏中，你需要一个领导板，每次提交一个新的分数时，你都要使用ZADD来更新它。
  使用ZRANGE可以很容易地获得顶级用户，还可以在给定用户名的情况下，使用ZRANK返回列表中的排名。
  将ZRANK和ZRANGE一起使用，可以向用户显示与给定用户相似的分数。一切都很快。
* 排序集通常用于索引存储在KeyDB中的数据。例如，如果有许多表示用户的散列，则可以使用排序集，其中的元素以用户的年龄作为得分，以用户的ID作为值。
  因此，使用ZRANGEBYSCORE检索具有给定年龄间隔的所有用户将是简单而快速的。

排序集可能是最高级的KeyDB数据类型，因此请花些时间检查排序集命令的完整列表，以发现可以使用KeyDB执行的操作！
另外，您可能需要阅读KeyDB数据类型的介绍。

## Bitmaps 和 HyperLogLogs

KeyDB还支持位图和超级日志，它们实际上是基于字符串基类型的数据类型，但有自己的语义。

有关这些类型的信息，请参阅commands部分中的KeyDB数据类型简介。

