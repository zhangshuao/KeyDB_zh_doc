# 大量插入

## 使用协议，Luke

使用普通的KeyDB客户机执行大规模插入不是一个好主意，
原因有几个：一个接一个地发送命令的天真方法很慢，因为您必须为每个命令支付往返时间。
可以使用pipelining，但对于大量插入的许多记录，您需要在同时读取答复的同时编写新命令，以确保插入速度尽可能快。

只有一小部分客户端支持非阻塞I/O，并不是所有的客户端都能够以高效的方式解析应答以最大化吞吐量。
出于所有这些原因，将数据大量导入KeyDB的首选方法是以原始格式生成包含KeyDB协议的文本文件，以便调用插入所需数据所需的命令。

例如，如果我需要生成一个大数据集，其中有数十亿个键的格式为：`keyN->ValueN'，我将创建一个文件，其中包含KeyDB协议格式的以下命令：

    SET Key0 Value0
    SET Key1 Value1
    ...
    SET KeyN ValueN

创建此文件后，剩下的操作是尽快将其馈送给KeyDB。在过去，这样做的方法是使用netcat和以下命令：

    (cat data.txt; sleep 10) | nc localhost 6379 > /dev/null

但是，这不是执行大规模导入的非常可靠的方法，因为netcat并不真正知道何时传输了所有数据，并且无法检查错误。
在2.6或更高版本的KeyDB中，keydb-cli实用程序支持一种称为pipe mode的新模式，该模式是为执行大规模插入而设计的。

使用管道模式运行命令如下所示：

    cat data.txt | keydb-cli --pipe

会产生类似的输出：

    All data transferred. Waiting for the last reply...
    Last reply received from server.
    errors: 0, replies: 1000000

keydb-cli实用程序还将确保只将从keydb实例接收到的错误重定向到标准输出

## 生成KeyDB协议

KeyDB协议的生成和解析非常简单，本文对此进行了说明。但是，为了生成协议以实现大规模插入的目标，您不需要了解协议的每个细节，
而只需要按照以下方式表示每个命令：

    *<args><cr><lf>
    $<len><cr><lf>
    <arg0><cr><lf>
    <arg1><cr><lf>
    ...
    <argN><cr><lf>

其中，<cr>表示"\r"（或ASCII字符13），<lf>表示"\n"（或ASCII字符10）。

例如，命令SET key value由以下协议表示：

    *3<cr><lf>
    $3<cr><lf>
    SET<cr><lf>
    $3<cr><lf>
    key<cr><lf>
    $5<cr><lf>
    value<cr><lf>

或用引号表示：

    "*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n"

需要生成以进行大规模插入的文件只是由以上述方式表示的一个接一个的命令组成。

以下Ruby函数生成有效的协议：

    def gen_KeyDB_proto(*cmd)
        proto = ""
        proto << "*"+cmd.length.to_s+"\r\n"
        cmd.each{|arg|
            proto << "$"+arg.to_s.bytesize.to_s+"\r\n"
            proto << arg.to_s+"\r\n"
        }
        proto
    end
    
    puts gen_KeyDB_proto("SET","mykey","Hello World!").inspect

使用上述功能，可以使用此程序轻松生成上述示例中的键值对：

    (0...1000).each{|n|
        STDOUT.write(gen_KeyDB_proto("SET","Key#{n}","Value#{n}"))
    }

为了执行第一次大规模导入会话，我们可以直接在keydb-cli的管道中运行该程序。

    $ ruby proto.rb | keydb-cli --pipe
    All data transferred. Waiting for the last reply...
    Last reply received from server.
    errors: 0, replies: 1000

## pipe管道模式如何在hoods面罩下工作

keydb-cli的管道模式所需要的魔力是与netcat一样快，并且仍然能够理解服务器在同一时间发送最后一个回复的时间。

这是通过以下方式获得的：

* keydb-cli --pipe尝试将数据尽可能快地发送到服务器。
* 同时，它在可用时读取数据，试图对其进行分析。
* 一旦没有更多的数据可从stdin读取，它将发送一个带有随机20字节字符串的特殊ECHO命令：
我们确信这是最新发送的命令，并且我们确信如果接收到与大容量回复相同的20字节，我们可以匹配回复检查。
* 一旦发送了这个特殊的final命令，接收回复的代码就开始用这个20字节来匹配回复。
当达到匹配回复时，它可以成功退出。

使用这个技巧，我们不需要解析发送到服务器的协议，就可以理解我们发送了多少命令，而只需要回复。
但是，在解析回复时，我们会对解析的所有回复进行计数，以便在最后能够告诉用户通过mass insert会话传输到服务器的命令数量。


