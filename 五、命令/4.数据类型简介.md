# 数据类型和抽象简介

KeyDB不是一个简单的键值存储，它实际上是一个数据结构服务器，支持不同类型的值。
这意味着，虽然在传统的键值中，将字符串键与字符串值关联起来，但在KeyDB中，该值不仅限于简单的字符串，还可以保存更复杂的数据结构。
以下是KeyDB支持的所有数据结构的列表，本教程将单独介绍这些结构

* Binary-safe 二进制安全字符串。
* Lists：根据插入顺序排序的字符串元素集合。它们基本上是链表。
* Sets, 唯一的、未排序的字符串元素的集合。
* Sorted sets, 类似于集合，但每个字符串元素都与一个浮点数（称为score）相关联。
               元素总是按其分数排序，因此与集合不同，可以检索一系列元素（例如，您可能会问：给我前10个，或后10个）。
* Hashes,  它们是由与值关联的字段组成的映射。字段和值都是字符串。这与Ruby或Python散列非常相似。
* Bit arrays (或简单的bitmaps位图）: 使用特殊命令，可以像处理一个位数组一样处理字符串值：可以设置和清除单个位，将所有位设置为1，
                                  查找第一个设置或未设置的位，等等。
* HyperLogLogs: 这是一种概率数据结构，用于估计集合的基数。别害怕，这比看起来简单多了。。。请参阅本教程的HyperLogLog部分的后面部分。
* Streams: 只追加提供抽象日志数据类型的类映射项集合。它们在KeyDB流简介中有详细介绍。

掌握这些数据类型的工作方式和使用什么来从命令引用中解决给定的问题并不总是那么简单，
因此本文是KeyDB数据类型及其最常见模式的一个速成课程。

对于所有示例，我们将使用keydb-cli实用程序（一个简单但方便的命令行实用程序）对keydb服务器发出命令。

## KeyDB keys

KeyDB key是二进制安全的，这意味着您可以使用任何二进制序列作为key，从"foo"这样的字符串到JPEG文件的内容。
空字符串也是有效的键。

关于key的其他一些规则：

* 很长的keys不是个好主意。例如，1024字节的key不仅在内存方面是个坏主意，
而且还因为在数据集中查找key可能需要几个代价高昂的key比较。
即使在手头的任务是匹配大值的存在时，散列它（例如用SHA1）是一个更好的想法，尤其是从内存和带宽的角度来看。

* 很短的keys通常不是个好主意。如果您可以写"user:1000:followers"，那么将"u1000flw"写为键就没有什么意义了。
与键对象本身和值对象所使用的空间相比，后者可读性更强，所添加的空间更小。
虽然短键显然会消耗更少的内存，但您的工作是找到正确的平衡点。

* 试着坚持一种模式。例如，"object-type:id"是个好主意，如"user:1000"。点或冒号通常用于多-字段，
如"comment:1234:reply.to"或"comment:1234:reply to""。

* 允许的最大key size为512MB。

## KeyDB Strings

KeyDB字符串类型是可以与KeyDB键关联的最简单的值类型。
它是Memcached中唯一的数据类型，所以对于新手来说在KeyDB中使用它也是很自然的。

因为KeyDB键是字符串，所以当我们使用字符串类型作为值时，我们将字符串映射到另一个字符串。
字符串数据类型对于许多用例都很有用，比如缓存HTML片段或页面。

让我们使用keydb-cli对字符串类型进行一些处理（在本教程中，所有示例都将通过keydb-cli执行）。

    > set mykey somevalue
    OK
    > get mykey
    "somevalue"

如您所见，使用SET和GET命令是我们设置和检索字符串值的方式。
注意，在key已经存在的情况下，即使key与非字符串值关联，
SET也将替换已存储到key中的任何现有值。所以SET执行赋值。

值可以是各种类型的字符串（包括二进制数据），例如，可以在值中存储jpeg图像。值不能大于512MB。

SET命令有一些有趣的选项，这些选项作为附加参数提供。
例如，如果key已经存在，或者相反，如果key已经存在，则可以成功地设置SET失败：

    > set mykey newval nx
    (nil)
    > set mykey newval xx
    OK

即使字符串是KeyDB的基本值，也可以对它们执行一些有趣的操作。例如，一个是原子增量：

    > set counter 100
    OK
    > incr counter
    (integer) 101
    > incr counter
    (integer) 102
    > incrby counter 50
    (integer) 152

INCR命令将字符串值解析为整数，并将其递增一，最后将获得的值设置为新值。
还有其他类似的命令，如INCRBY、DECR 和DECRBY。在内部，它总是相同的命令，以稍微不同的方式执行。

INCR是原子的是什么意思？即使多个client对同一个key发出INCR，也永远不会进入竞争状态。
例如，client 1永远不会同时读取"10"，client 2也不会同时读取"10"，两者都将递增为11，并将新值设置为11。
最终值将始终为12，并在所有其他客户端不同时执行命令的情况下执行读取增量集操作。

有许多用于操作字符串的命令。例如，GETSET命令将一个键设置为一个新值，并返回旧值作为结果。
例如，如果您有一个系统，每当您的网站接收到新访问者时，该系统都会使用INCR递增KeyDB key，则可以使用此命令。
您可能希望每小时收集一次此信息，而不会丢失一个增量。您可以获取设置键，将新值指定为"0"，并将旧值读回。

在单个命令中设置或检索多个键的值的能力对于减少延迟也很有用。因此，有MSET和MGET命令：

    > mset a 10 b 20 c 30
    OK
    > mget a b c
    1) "10"
    2) "20"
    3) "30"

使用MGET时，KeyDB返回一个值数组。

## 更改和查询key空间

有些命令不是在特定类型上定义的，但对于与键的空间交互非常有用，因此可以与任何类型的键一起使用。

例如，如果数据库中存在或不存在给定的key，则存在命令返回1或0，
而DEL命令则删除键和关联的值，无论值是什么。

    > set mykey hello
    OK
    > exists mykey
    (integer) 1
    > del mykey
    (integer) 1
    > exists mykey
    (integer) 0

从示例中，您也可以看到DEL本身如何返回1或0取决于该key是否被移除（它是否存在）（没有该名称的key）。

有许多与键空间相关的命令，但以上两个命令与TYPE命令一起是必需的，
TYPE命令返回存储在指定键上的值的类型：

    > set mykey x
    OK
    > type mykey
    string
    > del mykey
    (integer) 1
    > type mykey
    none

## KeyDB 过期：生存时间有限的key

在继续使用更复杂的数据结构之前，我们需要讨论另一个功能，它不考虑值类型，而是称为KeyDB expires。
基本上你可以为一个键设置一个超时，这是一个有限的生存时间。
当生存时间过去时，key会自动销毁，就像用户用key调用DEL命令一样。

关于KeyDB expires的一些快速信息：

* 它们可以使用秒或毫秒精度进行设置。
* 但是，过期时间分辨率始终为1毫秒。
* 关于expires的信息被复制并保存在磁盘上，当KeyDB服务器保持停止状态时（这意味着KeyDB将保存key到期的日期）。

设置expire很简单：

    > set key some-value
    OK
    > expire key 5
    (integer) 1
    > get key (immediately)
    "some-value"
    > get key (after some time)
    (nil)

由于第二个呼叫延迟了5秒以上，key在两个GET呼叫之间消失了。
在上面的例子中，我们使用EXPIRE来设置EXPIRE（它也可以用于为已经有一个EXPIRE的key设置不同的EXPIRE，比如PERSIST可以用于删除EXPIRE并使key永久保持）。
但是，我们也可以使用其他KeyDB命令创建带expires的键。例如，使用设置选项：

    > set key 100 ex 10
    OK
    > ttl key
    (integer) 9

上面的示例设置一个字符串值为100的键，其过期时间为10秒。稍后调用TTL命令以检查key的剩余生存时间。

要设置和检查以毫秒为单位的过期时间，请检查PEXPIRE和PTTL命令以及设置选项的完整列表。

## KeyDB Lists

为了解释列表数据类型，最好从一点理论开始，因为信息技术人员经常以不正确的方式使用术语列表。
例如，"Python列表"并不是这个名字可能暗示的内容（链接列表），
而是数组（在Ruby中，相同的数据类型实际上被称为Array）。

从一个非常普遍的观点来看，列表只是有序元素的序列：10,20,1,2,3是一个列表。
但是，使用数组实现的列表的属性与使用链接列表实现的列表的属性非常不同。

KeyDB列表通过链表实现。这意味着，即使列表中有数百万个元素，在列表的头部或尾部添加新元素的操作也将在恒定的时间内执行。
使用LPUSH命令向包含10个元素的列表的头部添加新元素的速度与向包含1000万个元素的列表的头部添加元素的速度相同。

有什么坏处？在用数组实现的列表中（常数时间索引访问）按索引访问一个元素非常快，
而在用链表实现的列表中（该操作需要与所访问元素的索引成比例的工作量）则不那么快。

KeyDB列表是用链表实现的，因为对于数据库系统来说，能够以非常快的方式将元素添加到非常长的列表中是至关重要的。
另一个强大的优势，如您稍后将看到的，是KeyDB列表可以在恒定时间内以恒定长度获取。

当快速访问大型元素集合的中间非常重要时，可以使用一种不同的数据结构，称为排序集。本教程稍后将介绍排序集。

## 第一步 使用KeyDB列表

LPUSH命令在左侧（头部）的列表中添加新元素，
而RPUSH命令在右侧（尾部）的列表中添加新元素。最后，LRANGE命令从列表中提取元素范围：

    > rpush mylist A
    (integer) 1
    > rpush mylist B
    (integer) 2
    > lpush mylist first
    (integer) 3
    > lrange mylist 0 -1
    1) "first"
    2) "A"
    3) "B"

注意LRANGE有两个索引，第一个和最后一个要返回的元素。这两个索引都可以是负数，
告诉KeyDB从末尾开始计数：所以-1是最后一个元素，-2是列表的倒数第二个元素，以此类推。

如您所见，RPUSH在列表右侧附加了元素，而最后一个LPUSH在左侧附加了元素。

这两个命令都是可变命令，这意味着您可以在单个调用中将多个元素推送到列表中：

    > rpush mylist 1 2 3 4 5 "foo bar"
    (integer) 9
    > lrange mylist 0 -1
    1) "first"
    2) "A"
    3) "B"
    4) "1"
    5) "2"
    6) "3"
    7) "4"
    8) "5"
    9) "foo bar"

KeyDB列表中定义的一个重要操作是弹出元素的能力。
弹出元素是同时从列表中检索元素和从列表中删除元素的操作。
您可以从左侧和右侧弹出元素，类似于如何推送列表两侧的元素：

    > rpush mylist a b c
    (integer) 3
    > rpop mylist
    "c"
    > rpop mylist
    "b"
    > rpop mylist
    "a"

我们添加了三个元素并弹出了三个元素，因此在这个命令序列的末尾，列表是空的，没有更多的元素可弹出。
如果我们尝试弹出另一个元素，这就是我们得到的结果：

    > rpop mylist
    (nil)

KeyDB返回了一个空值，表示列表中没有元素。

## 列表的常见用例

列表对于许多任务都很有用，下面是两个非常有代表性的用例：

* 记住用户在社交网络上发布的最新更新。
* 进程之间的通信，使用消费者-生产者模式，生产者将项目推送到列表中，消费者（通常是工人）使用这些项目和执行的操作。

KeyDB有特殊的list命令来使这个用例更加可靠和高效。

例如，流行的Ruby库resque和sidekiq都在引擎下使用KeyDB列表来实现后台作业。

受欢迎的Twitter社交网络将用户发布的最新tweets记录到KeyDB列表中。

为了逐步描述一个常见的用例，假设您的主页显示了照片共享社交网络中发布的最新照片，并且您希望加快访问速度。

* 每次用户发布新照片时，我们都会使用LPUSH将其ID添加到列表中。
* 当用户访问主页时，我们使用LRANGE 0 9来获取最新发布的10个项目。

## 顶层列表

在许多用例中，我们只想使用列表来存储最新的项目，不管它们是什么：社交网络更新、日志或其他任何东西。

KeyDB允许我们将列表用作有上限的集合，只记住最新的N个项，并使用LTRIM命令丢弃所有最旧的项。

LTRIM命令类似于LRANGE，但它没有显示指定的元素范围，而是将此范围设置为新的列表值。
所有超出给定范围的元素都将被删除。

举个例子可以更清楚地说明：

	> rpush mylist 1 2 3 4 5
	(integer) 5
	> ltrim mylist 0 2
	OK
	> lrange mylist 0 -1
	1) "1"
	2) "2"
	3) "3"

上面的LTRIM命令告诉KeyDB只从索引0到2获取列表元素，其他所有元素都将被丢弃。
这允许一个非常简单但有用的模式：同时执行列表推送操作和列表修剪操作，以便添加新元素和丢弃超过限制的元素：

	LPUSH mylist <some element>
	LTRIM mylist 0 999

上面的组合添加了一个新元素，并且只将1000个最新元素带入列表。
使用LRANGE，您可以访问最重要的项目，而无需记住非常旧的数据。

注意：虽然LRANGE在技术上是一个O(N)命令，但是访问列表头部或尾部的小范围是一个恒定的时间操作。

## 阻止列表上的操作

列表有一个特殊的特性，使得它们适合实现队列，并且通常作为进程间通信系统的构建块：阻塞操作。

想象一下，你想用一个进程将项目推送到一个列表中，然后使用另一个进程来实际处理这些项目。
这是常见的生产者/消费者设置，可以通过以下简单方式实现：

* 要将项推送到列表中，生产者调用LPUSH。
* 要从列表中提取/处理项目，消费者可以调用RPOP。

但是，有时列表可能是空的，并且没有要处理的内容，因此RPOP只返回NULL。
在这种情况下，使用者被迫等待一段时间，然后使用RPOP重试。
这称为轮询，在这种情况下不是一个好主意，因为它有几个缺点：

1.强制KeyDB和client处理无用的命令（当列表为空时，所有请求都将无法完成实际工作，它们只返回NULL）。
2.为项目的处理添加延迟，因为在工作进程收到空值后，它会等待一段时间。
为了减小延迟，我们可以减少对RPOP的调用之间的等待，从而放大问题1，即对KeyDB的无用调用。

因此KeyDB实现了名为BRPOP和BLPOP的命令，这两个命令是RPOP和LPOP的版本，
如果列表为空，它们可以阻止：只有在向列表中添加新元素或达到用户指定的超时时，它们才会返回调用方。

这是我们可以在worker中使用的BRPOP调用的示例：

    > brpop tasks 5
    1) "tasks"
    2) "do_something"

这意味着："等待列表任务中的元素，但如果5秒后没有元素可用，则返回"。

请注意，您可以使用0作为超时值来永远等待元素，您还可以指定多个列表而不仅仅是一个列表，
以便同时在多个列表上等待，并在第一个列表接收到元素时得到通知。

关于BRPOP有几点需要注意：

1.按顺序为client提供服务：阻止等待列表的第一个client，在某个元素被其他client推送时首先提供服务，依此类推。
2.返回值与RPOP不同：它是一个双元素数组，因为它还包括键的名称，因为BRPOP和BLPOP能够阻止从多个列表中等待元素。
3.如果达到超时，则返回空值。

你应该知道更多关于列表和阻塞操作的事情。我们建议您阅读以下内容：

* 可以使用RPOPLPUSH构建更安全的队列或循环队列。
* 还有一个命令的阻塞变体，叫做BRPOPLPUSH。

## 自动创建和删除key

到目前为止，在我们的示例中，我们从未在推送元素之前创建空列表，或者在元素不再包含元素时移除空列表。
当列表是空的时候删除键是KeyDB的责任，或者在key不存在的情况下创建一个空列表，并且我们试图添加元素，例如，用LPUSH。

这并不特定于列表，它适用于由多个元素（流、集、排序集和散列）组成的所有KeyDB数据类型。

基本上，我们可以用三个规则来总结这种行为：

1.当向聚合数据类型添加元素时，如果目标键不存在，则在添加元素之前创建空聚合数据类型。
2.当我们从聚合数据类型中移除元素时，如果该值保持为空，则键将自动销毁。流数据类型是此规则的唯一例外。
3.调用只读命令（如LLEN（返回列表的长度）或带有空键的write命令删除元素时，始终会产生相同的结果，
就好像键持有命令希望找到的类型的空聚合类型一样。

规则1的例子:

    > del mylist
    (integer) 1
    > lpush mylist 1 2 3
    (integer) 3

但是，如果存在key，则不能执行错误类型的操作：

    > set foo bar
    OK
    > lpush foo 1 2 3
    (error) WRONGTYPE Operation against a key holding the wrong kind of value
    > type foo
    string

规则2的例子：

    > lpush mylist 1 2 3
    (integer) 3
    > exists mylist
    (integer) 1
    > lpop mylist
    "3"
    > lpop mylist
    "2"
    > lpop mylist
    "1"
    > exists mylist
    (integer) 0

在弹出所有元素之后，key不再存在。

规则3的例子：

    > del mylist
    (integer) 0
    > llen mylist
    (integer) 0
    > lpop mylist
    (nil

## KeyDB Hashes

KeyDB散列与字段-值对的"散列"外观完全相同：

    > hmset user:1000 username john birthyear 1977 verified 1
    OK
    > hget user:1000 username
    "john"
    > hget user:1000 birthyear
    "1977"
    > hgetall user:1000
    1) "username"
    2) "john"
    3) "birthyear"
    4) "1977"
    5) "verified"
    6) "1"

虽然散列可以方便地表示对象，但实际上可以放入散列中的字段数量没有实际限制（除了可用内存），
因此可以在应用程序中以多种不同的方式使用散列。

命令HMSET设置散列的多个字段，而HGET检索单个字段。HMGET类似于HGET，但返回一个值数组：

    > hmget user:1000 username birthyear no-such-field
    1) "john"
    2) "1977"
    3) (nil)

还有一些命令也可以对单个字段执行操作，如HINCRBY：

    > hincrby user:1000 birthyear 10
    (integer) 1987
    > hincrby user:1000 birthyear 10
    (integer) 1997

您可以在文档中找到散列命令的完整列表。

值得注意的是，小散列（即一些具有小值的元素）是以特殊的方式在内存中编码的，这使得它们非常具有内存效率。

## KeyDB Sets

KeyDB集是字符串的无序集合。SADD命令向集合添加新元素。如果给定元素已经存在，执行多个集合之间的交集、合并或差异等，
也可以对集合进行许多其他测试，如测试 等等。

    > sadd myset 1 2 3
    (integer) 3
    > smembers myset
    1. 3
    2. 1
    3. 2

在这里，我向集合中添加了三个元素，并告诉KeyDB返回所有元素。正如您所看到的，
它们没有被排序--KeyDB可以在每次调用时按任意顺序返回元素，因为在元素排序方面与用户没有约定。

KeyDB有用于测试成员身份的命令。例如，检查元素是否存在：

    > sismember myset 3
    (integer) 1
    > sismember myset 30
    (integer) 0

"3"是集合的成员，而"30"不是。

集合有利于表达对象之间的关系。例如，我们可以很容易地使用集合来实现标记。

为这个问题建模的一个简单方法是为每个要标记的对象设置一个集合。集合包含与对象关联的标记的ID。

一个例子是给新闻文章加标签。如果文章ID 1000使用标记1、2、5和77进行标记，则集合可以将这些标记ID与新闻项关联：

    > sadd news:1000:tags 1 2 5 77
    (integer) 4

我们可能还希望有一个相反的关系：用给定标记标记的所有新闻的列表：

    > sadd tag:1:news 1000
    (integer) 1
    > sadd tag:2:news 1000
    (integer) 1
    > sadd tag:5:news 1000
    (integer) 1
    > sadd tag:77:news 1000
    (integer) 1

获取给定对象的所有标记很简单：

    > smembers news:1000:tags
    1. 5
    2. 1
    3. 77
    4. 2

注意：在这个例子中，我们假设您有另一个数据结构，例如KeyDB散列，它将标记id映射到标记名。

还有其他一些非平凡的操作仍然很容易使用正确的KeyDB命令实现。
例如，我们可能需要一个包含标记1、2、10和27的所有对象的列表。
我们可以使用SINTER命令来实现这一点，该命令执行不同集合之间的交集。我们可以使用：

    > sinter tag:1:news tag:2:news tag:10:news tag:27:news
    ... results here ...

除了交集，还可以执行并集、差分、提取随机元素等。

提取元素的命令称为SPOP，它很容易对某些问题建模。
例如，为了实现一个基于web的扑克游戏，您可能需要用一个集合来表示您的牌组。
假设我们为（C）lubs，（D）iamonds，（H）earts，（S）pades使用一个字符前缀：

>  sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK
   D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3
   H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6
   S7 S8 S9 S10 SJ SQ SK
   (integer) 52
   
现在我们要为每个玩家提供5张牌。SPOP命令删除一个随机元素，并将其返回给client，因此在本例中这是一个完美的操作。

然而，如果我们直接对牌组调用它，在下一个游戏中，我们将需要再次填充牌组，这可能不是理想的。
因此，首先，我们可以将存储在deck key中的集合复制到游戏中：game:1:deck key。

这是使用SUNIONSTORE实现的，SUNIONSTORE通常执行多个集合之间的并集，并将结果存储到另一个集合中。
但是，由于一个集合的并集本身，我可以复制我的数据集：   
   
    > sunionstore game:1:deck deck
    (integer) 52

现在我准备为第一个玩家提供五张牌：
   
    > spop game:1:deck
    "C6"
    > spop game:1:deck
    "CQ"
    > spop game:1:deck
    "D1"
    > spop game:1:deck
    "CJ"
    > spop game:1:deck
    "SJ"

一对jacks，不太好。。。

现在是引入set命令的好时机，该命令提供集合内元素的数量。
在集合论的上下文中，这通常被称为集合的基数，因此KeyDB命令被称为SCARD。   
  
    > scard game:1:deck
    (integer) 47

数学运算：52 - 5 = 47。

当您需要只获取随机元素而不从集合中移除它们时，有适合于该任务的SRANDMEMBER命令。
它还具有返回重复和非重复元素的功能。   
   
## KeyDB Sorted sets

排序集是一种数据类型，类似于集和散列之间的混合。
与集合一样，排序集合由唯一的、不重复的字符串元素组成，因此在某种意义上，排序集合也是集合。

然而，虽然集合中的元素没有排序，但排序集合中的每个元素都与一个名为score的浮点值相关联
（这就是为什么该类型也类似于散列，因为每个元素都映射到一个值）。

此外，排序集中的元素是按顺序获取的（因此它们不是按请求排序的，顺序是用于表示排序集的数据结构的一个特性）。
它们的订购规则如下：

    * 如果A和B是得分不同的两个元素，那么A>B如果A.score>B.score。
    * 如果A和B具有完全相同的分数，则如果A字符串大于B字符串，则A＞B。
      A和B字符串不能相等，因为排序集只有唯一的元素。

让我们从一个简单的例子开始，添加一些选定的黑客名称作为排序集元素，其出生年份为"score"。
    
    > zadd hackers 1940 "Alan Kay"
    (integer) 1
    > zadd hackers 1957 "Sophie Wilson"
    (integer) 1
    > zadd hackers 1953 "Richard Stallman"
    (integer) 1
    > zadd hackers 1949 "Anita Borg"
    (integer) 1
    > zadd hackers 1965 "Yukihiro Matsumoto"
    (integer) 1
    > zadd hackers 1914 "Hedy Lamarr"
    (integer) 1
    > zadd hackers 1916 "Claude Shannon"
    (integer) 1
    > zadd hackers 1969 "Linus Torvalds"
    (integer) 1
    > zadd hackers 1912 "Alan Turing"
    (integer) 1

正如您所看到的，ZADD与SADD类似，但是需要一个额外的参数（放在要添加的元素之前），这就是得分。
ZADD也是可变的，因此您可以自由地指定多个得分-值对，即使在上面的示例中没有使用它。

对于排序集，返回按其出生年份排序的黑客列表很简单，因为实际上它们已经排序。

实现说明：排序集通过包含跳过列表和哈希表的双端口数据结构实现，因此每次添加元素KeyDB时都执行O(log(N))操作。
很好，但是当我们要求排序元素时，KeyDB根本不需要做任何工作，它已经全部排序了：

    > zrange hackers 0 -1
    1) "Alan Turing"
    2) "Hedy Lamarr"
    3) "Claude Shannon"
    4) "Alan Kay"
    5) "Anita Borg"
    6) "Richard Stallman"
    7) "Sophie Wilson"
    8) "Yukihiro Matsumoto"
    9) "Linus Torvalds"

注意：0和-1表示从元素索引0到最后一个元素（-1在这里的工作方式与LRANGE命令一样）。

如果我要相反的顺序，从最小到最大怎么办？使用ZREVRANGE而不是ZRANGE：

	> zrevrange hackers 0 -1
	1) "Linus Torvalds"
	2) "Yukihiro Matsumoto"
	3) "Sophie Wilson"
	4) "Richard Stallman"
	5) "Anita Borg"
	6) "Alan Kay"
	7) "Claude Shannon"
	8) "Hedy Lamarr"
	9) "Alan Turing"

也可以使用WITHSCORES参数返回分数：

	> zrange hackers 0 -1 withscores
	1) "Alan Turing"
	2) "1912"
	3) "Hedy Lamarr"
	4) "1914"
	5) "Claude Shannon"
	6) "1916"
	7) "Alan Kay"
	8) "1940"
	9) "Anita Borg"
	10) "1949"
	11) "Richard Stallman"
	12) "1953"
	13) "Sophie Wilson"
	14) "1957"
	15) "Yukihiro Matsumoto"
	16) "1965"
	17) "Linus Torvalds"
	18) "1969"

## 操作范围

排序集比这更强大。他们可以在靶场上操作。
让我们把1950年以前出生的所有人都包括在内。我们使用ZRANGEBYSCORE命令来执行此操作：

	> zrangebyscore hackers -inf 1950
	1) "Alan Turing"
	2) "Hedy Lamarr"
	3) "Claude Shannon"
	4) "Alan Kay"
	5) "Anita Borg"

我们要求KeyDB返回所有得分介于负无穷大和1950之间的元素（包括两个极端）。

也可以删除元素的范围。让我们把1940年到1960年间出生的所有黑客从分类集中删除：

	> zremrangebyscore hackers 1940 1960
	(integer) 4

ZREMRANGEBYSCORE可能不是最好的命令名，但它可能非常有用，并返回删除的元素数。

为排序集元素定义的另一个非常有用的操作是get-rank操作。可以询问元素在有序元素集中的位置。

	> zrank hackers "Anita Borg"
	(integer) 4

考虑到按降序排序的元素，也可以使用ZREVRANK命令来获取rank。

## 词典式分数

在最近版本的KEYDB 2.8中，引入了一种新的特征，它允许字典中的范围，
假设排序的集合中的元素都插入了相同的相同的分数（元素与C MMECMP函数比较，因此保证没有排序，并且每个KEKDB实例将以相同的输出应答）。

使用字典范围操作的主要命令是ZRANGEBYLEX，ZREVRANGEBYLEX，ZREMRANGEBYLEX和ZLEXCOUNT。

例如，让我们再次添加著名hackers的列表，但这次对所有元素使用0分：

> zadd hackers 0 "Alan Kay" 0 "Sophie Wilson" 0 "Richard Stallman" 0
  "Anita Borg" 0 "Yukihiro Matsumoto" 0 "Hedy Lamarr" 0 "Claude Shannon"
  0 "Linus Torvalds" 0 "Alan Turing"

由于排序的集合排序规则，它们已经按字典排序了：

	> zrange hackers 0 -1
	1) "Alan Kay"
	2) "Alan Turing"
	3) "Anita Borg"
	4) "Claude Shannon"
	5) "Hedy Lamarr"
	6) "Linus Torvalds"
	7) "Richard Stallman"
	8) "Sophie Wilson"
	9) "Yukihiro Matsumoto"

使用ZRANGEBYLEX，我们可以要求词典范围：

	> zrangebylex hackers [B [P
	1) "Claude Shannon"
	2) "Hedy Lamarr"
	3) "Linus Torvalds"

范围可以是inclusive或exclusive（取决于第一个字符），还可以使用+和-字符串分别指定字符串infinite和负infinite。
有关详细信息，请参阅文档。

这个特性很重要，因为它允许我们使用排序集作为泛型索引。
例如，如果要使用128位无符号整数参数对元素进行索引，则只需将元素添加到具有相同分数（例如0）但具有16字节前缀（由128位大端数字组成）的排序集中。
由于大字节中的数字，当按字典顺序排序（在原始字节顺序中）实际上也是按数字顺序排列的，可以在128位空间中请求范围，并获得元素的值，丢弃前缀。

如果您想在更严肃的演示环境中看到该功能，请检查KeyDB autocomplete演示。

## 更新分数：领导委员会

在切换到下一个主题之前，只需要最后一个关于排序集的注释。
排序集的分数可以随时更新。只调用ZADD对已经排序的集合中包含的元素将用O(log(N))时间复杂度更新其得分（和位置）。
因此，当有大量更新时，排序集是合适的。

由于这个特性，一个常见的用例是leader boards。典型的应用程序是一个Facebook游戏，
在这个游戏中，你可以根据用户的高分进行排序，再加上get rank操作，以显示排名前N的用户，
以及用户在排行榜中的排名（例如，"你是这里的#4932最佳分数"）。

## Bitmaps 位图

位图不是实际的数据类型，而是在字符串类型上定义的一组面向位的操作。
由于字符串是二进制的安全斑点，它们的最大长度是512MB，所以它们适合设置为2^32个不同的位。

位操作分为两组：固定时间的单位操作，如将位设置为1或0，或获取其值，
以及对一组位的操作，例如计算给定位范围内的设置位数（例如，总体计数）。

位图最大的优点之一是，它们在存储信息时通常可以极大地节省空间。
例如，在不同用户由递增的用户id表示的系统中，仅使用512mb的内存就可以记住40亿用户的单个比特信息(例如，知道用户是否想要接收时事通讯)。

使用SETBIT和GETBIT命令设置和检索位：

	> setbit key 10 1
	(integer) 1
	> getbit key 10
	(integer) 1
	> getbit key 11
	(integer) 0

SETBIT命令将位号作为第一个参数，将位设置为的值作为第二个参数，即1或0。
如果地址位超出当前字符串长度，则该命令会自动放大字符串。

GETBIT只返回指定索引处的位的值。
超出范围的位（对存储在目标键中的字符串长度以外的位进行寻址）始终被视为零。

有三个命令在一组位上操作：

1.BITOP在不同字符串之间执行按位操作。提供的操作是AND、OR、XOR和NOT。
2.BITCOUNT执行填充计数，报告设置为1的位数。
3.BITPOS查找指定值为0或1的第一个位。

BITPOS和BITCOUNT都可以在字符串的字节范围内操作，而不是在字符串的整个长度内运行。
下面是位计数调用的一个简单示例：

	> setbit key 0 1
	(integer) 0
	> setbit key 100 1
	(integer) 0
	> bitcount key
	(integer) 2

位图的常见用例有：

* 各种实时分析。
* 存储与对象id相关联的节省空间但高性能的布尔信息。

例如，假设您想知道网站用户每天访问的最长连续时间。你开始从零开始计算天数，也就是你公开你的网站的那一天，并在用户每次访问网站时设置一些挫折。
作为位索引，您只需将当前unix时间减去初始偏移量，然后除以3600*24。

这样，对于每个用户，您都有一个包含每天访问信息的小字符串。使用BITCOUNT可以很容易地获得给定用户访问网站的天数，
而使用一些BITPOS调用，或者简单地获取和分析位图客户端，则可以很容易地计算最长的条纹。

将位图拆分为多个键很简单，例如为了对数据集进行分片，并且通常最好避免使用大键。
为了将位图分割成不同的键，而不是将所有的位都设置为键，一个简单的策略就是为每个键存储M个位，
并获得具有bit-number/M的键名和要在具有位号MOD M的键内寻址的第n个位。

## HyperLogLogs

HyperLogLog是一种概率数据结构，用于计算唯一的事物（技术上这是指估计集合的基数）。
通常，计算唯一项需要使用与要计算的项数成比例的内存量，因为您需要记住以前看到的元素，以避免多次计算。
然而，有一组算法是用内存换取精度的：以一个标准错误（在KeyDB实现的情况下，标准错误小于1%）作为估计度量的结尾。
这个算法的神奇之处在于，你不再需要使用与计数项目数成比例的内存量，而是可以使用恒定的内存量！
在最坏的情况下是12k字节，如果你的HyperLogLog（我们从现在开始将它们称为HLL）很少看到元素的话，那就更少了。

KeyDB中的HLL在技术上是一个不同的数据结构，但编码为KeyDB字符串，因此可以调用GET来序列化HLL，
并将其设置为反序列化回服务器。

从概念上讲，HLL API类似于使用集合来执行相同的任务。您可以将每个观察到的元素添加到一个集合中，
并使用SCAD来检查集合内元素的数量，这是唯一的，因为SADD不会重新添加现有元素。

虽然您并没有真正将项添加到HLL中，但由于数据结构只包含不包含实际元素的状态，因此API是相同的：

* 每次看到新元素时，都会使用PFADD将其添加到计数中。
* 每次您想检索当前添加到PFADD的唯一元素的当前近似值时，就使用PFCOUNT。

	> pfadd hll a b c d
	  (integer) 1
	  > pfcount hll
	  (integer) 4

此数据结构的一个用例示例是计算用户每天在搜索表单中执行的唯一查询。

## 其他显著特征

KeyDB API中还有其他一些重要的东西不能在本文档的上下文中进行探讨，但值得您注意：

* 可以使用scan命令[逐步迭代大型集合的key空间
* 可以在服务器端运行Lua脚本（eval命令）来提高延迟和带宽。
* KeyDB也是一个Pub-Sub服务器。

## 了解更多

本教程一点也不完整，只介绍了API的基本知识。阅读完整的命令参考以了解更多信息。
感谢您的阅读，并用KeyDB玩得开心！

