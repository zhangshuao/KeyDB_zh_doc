# 分区：如何在多个实例之间分割数据

分区是将数据分割成多个KeyDB实例的过程，这样每个实例只包含一个子集的键。
本文的第一部分将向您介绍分区的概念，第二部分将向您展示KeyDB分区的替代方案。

## 为什么分区是有用的

KeyDB中的分区有两个主要目标：

    它允许更大的数据库，使用许多计算机的内存总和。如果不进行分区，则仅限于一台计算机可以支持的内存量。
    它允许将计算能力扩展到多个核心和多台计算机，将网络带宽扩展到多台计算机和网络适配器。

## 分区基础知识

有不同的分区标准。假设我们有四个KeyDB实例R0、R1、R2、R3，以及许多表示用户的键，
比如user:1、user:2、。。。等等，我们可以找到不同的方法来选择存储给定key的实例。
换句话说，有不同的系统将给定的key映射到给定的KeyDB服务器。

执行分区的最简单方法之一是使用范围分区，并通过将对象的范围映射到特定的KeyDB实例来完成。
例如，我可以说从ID 0到ID 10000的用户将进入实例R0，而从ID 10001到ID 20000的用户将进入实例R1，以此类推。

这个系统可以工作，并且实际使用中，但是它的缺点是需要一个映射范围到实例的表。
这个表需要管理，每种对象都需要一个表，因此KeyDB中的范围分区通常是不可取的，因为它比其他替代分区方法效率要低得多。

范围分区的另一种选择是散列分区。此方案可与任何key一起使用，而不需要表单object_name:<id>中的key，并且非常简单：

    * 取key名并使用哈希函数（例如crc32哈希函数）将其转换为数字。
    例如，如果键是foobar，crc32（foobar）将输出类似93024922的内容。
    
    * 对这个数字使用一个模运算，以便将它转换成一个介于0和3之间的数字，这样这个数字就可以映射到我的四个KeyDB实例中的一个。
    93024922模4等于2，所以我知道我的键foobar应该存储在R2实例中。注意：模运算返回除法运算的余数，在许多编程语言中用%运算符实现。

执行分区还有很多其他方法，但是通过这两个例子，您应该了解这个想法。
散列分区的一种高级形式称为一致散列，它由几个不相关的客户机和代理实现。

## 分区的不同实现

分区可以由软件堆栈的不同部分负责。

* **客户端分区**意味着客户端直接选择正确的节点来写入或读取给定的key。许多KeyDB客户端实现客户端分区。

* **代理辅助分区**意味着我们的客户机将请求发送到能够使用KeyDB协议的代理，而不是直接将请求发送到正确的KeyDB实例。
    代理将确保根据配置的分区架构将我们的请求转发到正确的KeyDB实例，并将回复发送回客户端。KeyDB和Memcached代理Twemproxy实现了代理辅助分区。

* **查询路由**意味着您可以将查询发送到随机实例，该实例将确保将查询转发到正确的节点。
    KeyDB集群在客户端的帮助下实现了一种混合形式的查询路由（请求不会从KeyDB实例直接转发到另一个实例，但客户端会被重定向到正确的节点）。

## 分区的缺点

KeyDB的一些特性在分区中发挥得不太好：

* 通常不支持涉及多个键的操作。例如，如果两个集合存储在映射到不同KeyDB实例的键中，则不能执行它们之间的交集（实际上有方法可以这样做，但不能直接这样做）。
* 不能使用涉及多个key的KeyDB事务。
* 分区粒度是关键，因此不可能用一个巨大的key（比如一个非常大的排序集）来切分数据集。
* 使用分区时，数据处理更为复杂，例如，必须处理多个rdb/aof文件，要备份数据，需要从多个实例和主机聚合持久性文件。

添加和删除容量可能很复杂。例如，KEYDB集群支持数据的透明重新平衡，在运行时可以添加和删除节点，
但其他系统（如客户端分区和代理）不支持此功能。然而，一种叫做预切分Pre-sharding的技术在这方面有帮助。

## 数据存储还是缓存？

尽管KeyDB中的分区在概念上是相同的，无论是将KeyDB用作数据存储还是用作缓存，
但是在将其用作数据存储时有一个明显的限制。当KeyDB用作数据存储时，给定的key必须始终映射到同一个KeyDB实例。
当KeyDB用作缓存时，如果给定的节点不可用，那么如果使用不同的节点，按照我们希望提高系统可用性（即，系统响应查询的能力）的方式更改key实例映射，
就不是什么大问题。

如果给定key的首选节点不可用，一致哈希实现通常能够切换到其他节点。
类似地，如果添加一个新节点，新key的一部分将开始存储在新节点上。

这里的主要概念如下：

* 如果KeyDB用作缓存，那么使用一致的散列就很容易**上下扩展**。

* 如果KeyDB用作存储，则使用固定的节点键映射，因此节点数必须固定且不能变化。
  否则，需要一个系统，该系统能够在添加或删除节点时重新平衡节点之间的key，并且当前只有KeyDB Cluster能够做到这一点-KeyDB Cluster通常是可用的，
  并且生产准备就绪。

## Pre-sharding 预切分

我们了解到分区的一个问题是，除非我们使用KeyDB作为缓存，否则添加和删除节点可能会很棘手，
而且使用固定键实例映射要简单得多。

但是，数据存储需求可能会随时间而变化。今天我可以使用10个KeyDB节点（实例），但明天可能需要50个节点。

由于KeyDB占用空间非常小，而且非常轻量级（一个备用实例使用1MB内存），解决这个问题的一个简单方法是从一开始就使用许多实例。
即使您从一台服务器开始，您也可以决定从第一天起就生活在一个分布式世界中，并使用分区在单个服务器中运行多个KeyDB实例。

你可以从一开始就选择大量的实例。例如，32或64个实例可以为大多数用户提供足够的增长空间。

这样，随着数据存储需求的增加和KeyDB服务器的增多，只需将实例从一个服务器移动到另一个服务器。
添加第一个附加服务器后，需要将一半KeyDB实例从第一个服务器移动到第二个服务器，依此类推。

使用KeyDB复制，您很可能可以在用户停机时间最少或不停机的情况下完成移动：

* 在新服务器中启动空实例。
* 移动数据，将这些新实例配置为源实例的slave实例。
* 阻止你的client。
* 使用新的服务器IP地址更新移动实例的配置。
* 向新服务器中的slave服务器发送SLAVEOF NO ONE命令。
* 使用新的更新配置重新启动客户端。
* 最后关闭旧服务器中不再使用的实例。

# KeyDB分区的实现

到目前为止，我们在理论上讨论了KeyDB分区，但是实践呢？你应该使用什么系统？

## KeyDB 集群

KeyDB集群是获得自动分片和高可用性的首选方法。自2015年4月1日起，该产品正式上市并投入生产。
您可以在集群教程中获得有关KeyDB集群的更多信息。

一旦KeyDB集群可用，并且如果KeyDB集群兼容的客户端可用于您的语言，KeyDB集群将成为KeyDB分区的事实标准。

KeyDB集群是查询路由和客户端分区的混合体。

## Twemproxy

Twemproxy是Twitter为Memcached ASCII和KeyDB协议开发的一个代理。
它是单线程的，用C语言编写，速度非常快。它是根据Apache2.0许可条款发布的开源软件。

Twemproxy支持在多个KeyDB实例之间进行自动分区，如果节点不可用，
则可以使用可选的节点弹出功能（这将更改KeyDB实例映射，因此只有在将KeyDB用作缓存时才应使用此功能）。

这不是一个单一的故障点，因为您可以启动多个代理，并指示您的客户端连接到第一个接受连接。

基本上，TwitePro是客户机和KEYDB实例之间的中间层，它将以最小的附加复杂性可靠地处理我们的分区。

## 支持一致哈希的客户端

    Twemproxy的另一种选择是使用通过一致的散列或其他类似算法实现客户端分区的客户端。
    有多个KeyDB客户机支持一致的散列，特别是redis-rb和Predis。
    
    请检查redis客户端（KeyDB兼容）的完整列表，以检查是否有适合您的语言的具有一致哈希实现的成熟客户端。


