# 键空间通知

## 功能概述

Keyspace通知允许客户端订阅Pub/Sub通道，以便接收以某种方式影响KeyDB数据集的事件。

可以接收的事件示例如下：

* 影响给定键的所有命令。
* 所有接受LPUSH操作的key。
* 数据库0中过期的所有key。

事件是使用KeyDB的普通Pub/Sub层传递的，因此实现Pub/Sub的客户机可以使用这个特性而无需修改。

由于KeyDB Pub/Sub已启动且当前已忘记，因此如果应用程序要求可靠的事件通知（即，如果Pub/Sub客户端断开连接并稍后重新连接），
则无法使用此功能，因此在客户端断开连接期间传递的所有事件都将丢失。

将来有计划允许更可靠地交付事件，但这可能会在更一般的级别上解决，要么为Pub/Sub本身带来可靠性，
要么允许Lua脚本拦截Pub/Sub消息以执行将事件推送到列表中之类的操作。

## 事件类型

键空间通知是为每个影响KeyDB数据空间的操作发送两种不同类型的事件来实现的。
例如，针对数据库0中名为mykey的键的DEL操作将触发两条消息的传递，这完全等同于以下两个发布命令：

    PUBLISH __keyspace@0__:mykey del
    PUBLISH __keyevent@0__:del mykey

很容易看出一个通道如何允许监听针对key mykey的所有事件，而另一个通道如何允许获取del操作的所有目标key的信息。
第一种在通道中使用Keyspace前缀的事件称为key空间通知，而第二种使用keysevent前缀的事件称为key事件通知。
在上面的示例中，为键mykey生成了del事件。结果是：

    * key空间通道接收事件的名称作为消息。
    * key事件通道接收key名称作为消息。

为了只传递我们感兴趣的事件的子集，只启用一种通知是可能的。

## 配置

默认情况下，键空间事件通知被禁用，因为虽然这项功能不太合理，但它使用了一些CPU能力。
使用keydb.conf的notify keyspace事件或通过配置集启用通知。

将参数设置为空字符串将禁用通知。为了启用该功能，使用一个非空字符串，由多个字符组成，其中每个字符根据下表具有特殊含义：

    K     Keyspace events, published with __keyspace@<db>__ prefix.
    E     Keyevent events, published with __keyevent@<db>__ prefix.
    g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
    $     String commands
    l     List commands
    s     Set commands
    h     Hash commands
    z     Sorted set commands
    x     Expired events (events generated every time a key expires)
    e     Evicted events (events generated when a key is evicted for maxmemory)
    A     Alias for g$lshzxe, so that the "AKE" string means all the events.

字符串中至少应该存在K或E，否则无论字符串的其余部分如何，都不会传递任何事件。

例如，要启用列表的键空间事件，配置参数必须设置为Kl，以此类推。

KEA字符串可用于启用所有可能的事件。

## 由不同命令生成的事件

根据以下列表，不同的命令生成不同类型的事件。

    * DEL为每个删除的key生成一个DEL事件。
    
    * RENAME生成两个事件：源key的RENAME_from事件和目标key的RENAME_to事件。
    
    * EXPIRE在将EXPIRE设置为key时生成EXPIRE事件，或者每次在key上设置正超时时生成expired事件，导致删除key（有关详细信息，请参阅EXPIRE文档）。
    
    * SORT在使用STORE设置新key时生成sortstore事件。如果生成的列表是空的，并且使用存储选项，并且已经存在具有该名称的现有key，则结果是键被删除，因此在此条件下生成DEL事件。
    
    * SET及其所有变体（SETEX、SETNX、GETSET）生成SET事件。但是SETEX也会生成一个expire事件。
    
    * MSET为每个key生成一个单独的set事件。
    
    * SETRANGE生成SETRANGE事件。
    
    * INCR、DECR、INCRBY、DECRBY命令都会生成INCRBY事件。
    
    * INCRBYFLOAT生成INCRBYFLOAT事件。
    
    * APPEND生成一个APPEND事件。
    
    * LPUSH和LPUSHX生成单个LPUSH事件，即使在可变情况下也是如此。
    
    * RPUSH和RPUSHX生成单个RPUSH事件，即使在可变情况下也是如此。
    
    * RPOP生成RPOP事件。此外，如果由于弹出列表中的最后一个元素而删除了键，则会生成del事件。
    
    * LPOP生成LPOP事件。此外，如果由于弹出列表中的最后一个元素而删除了键，则会生成del事件。
    
    * LINSERT生成一个LINSERT事件。
    
    * LSET生成LSET事件。
    
    * LREM生成一个LREM事件，如果结果列表为空并且key被移除，则生成一个del事件。
    
    * LTRIM生成一个LTRIM事件，另外，如果结果列表为空且键被移除，则生成一个del事件。
    
    * RPOPLPUSH和BRPOPLPUSH生成rpop事件和lpPush事件。在这两种情况下，订单都是有保证的（lpush事件总是在rpop事件之后交付）。
      另外，如果结果列表的长度为零，并且键被移除，则将生成del事件。
    
    * HSET、HSETNX和HMSET都生成一个HSET事件。
    
    * HINCRBY生成HINCRBY事件。
    
    * HINCRBYFLOAT生成HINCRBYFLOAT事件。
    
    * HDEL生成一个HDEL事件，如果结果哈希为空并且key被移除，则生成一个额外的del事件。
    
    * SADD生成单个SADD事件，即使在可变情况下也是如此。
    
    * SREM生成一个SREM事件，如果结果集为空并且key被移除，则生成一个额外的del事件。
    
    * SMOVE为源密钥生成srem事件，为目标key生成sadd事件。
    
    * SPOP生成一个SPOP事件，如果结果集为空并且key被移除，则生成一个额外的del事件。
    
    * SINTERSTORE、SUNIONSTORE、SDIFFSTORE分别生成SINTERSTORE、sunionostore、SDIFFSTORE事件。
     在特殊情况下，结果集是空的，并且结果存储的key已经存在，因为删除了key，所以生成了DEL事件。
    
    * ZINCR生成ZINCR事件。
    
    * 即使添加了多个元素，ZADD也会生成单个ZADD事件。
    
    * 即使删除多个元素，ZREM也会生成单个ZREM事件。当结果排序集为空并生成键时，将生成另一个del事件。
    
    * ZREMBYSCORE生成单个ZREMBYSCORE事件。当结果排序集为空并生成键时，将生成另一个del事件。
    
    * ZREMBYRANK生成单个ZREMBYRANK事件。当结果排序集为空并生成键时，将生成另一个del事件。
    
    * ZINTERSTORE和ZUNIONSTORE分别生成ZINTERSTORE和ZUNIONSTORE事件。
      在特殊情况下，结果排序的集合是空的，并且结果存储的key已经存在，因为删除了key，生成了DEL事件。
    
    * 每次将具有关联生存时间的key从数据集中移除时，都会生成过期事件。
    
    * 由于maxmemory策略，每次为了释放内存而从数据集中逐出key时，都会生成逐出事件。

**重要信息：** 只有当目标键被真正修改时，所有命令才会生成事件。
  例如，从一个集合中删除一个不存在的元素的SRIM实际上不会改变key的值，所以不会生成任何事件。

如果对如何为给定命令生成事件有疑问，最简单的方法就是观察自己：

    $ keydb-cli config set notify-keyspace-events KEA
    $ keydb-cli --csv psubscribe '__key*__:*'
    Reading messages... (press Ctrl-C to quit)
    "psubscribe","__key*__:*",1

此时，在另一个终端中使用keydb-cli向KeyDB服务器发送命令，并监视生成的事件：

    "pmessage","__key*__:*","__keyspace@0__:foo","set"
    "pmessage","__key*__:*","__keyevent@0__:set","foo"
    ...

## 过期事件的时间安排

KeyDB以两种方式过期与生存时间关联的key：

    * 当通过命令访问密钥并发现该key已过期时。
    * 通过后台系统，以增量方式在后台查找过期key，以便还能收集从未访问过的key。

当上述系统之一访问key并发现key已过期时，将生成过期事件，
因此无法保证KeyDB服务器能够在key生存时间达到零时生成过期事件。

如果没有命令持续地以key为目标，并且有许多与TTL相关联的key，则在key生存时间降至零和生成过期事件之间可能存在明显的延迟。

基本上，**当KeyDB服务器删除key时**， 而不是当生存时间理论上达到零时，会生成过期事件。

