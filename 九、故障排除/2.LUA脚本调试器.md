# 用LUA调试器调试LUA脚本

KeyDB包含一个完整的Lua调试器，可以使用它来简化编写复杂KeyDB脚本的任务。

KeyDB Lua调试器codename LDB具有以下重要功能：

* 它使用服务器-客户端模型，因此是一个远程调试器。KeyDB服务器充当调试服务器，而默认客户端是keydb-cli。但是，其他客户机可以按照服务器实现的简单协议进行开发。
* 默认情况下，每个新的调试会话都是分叉会话。这意味着在调试KeyDB Lua脚本时，服务器不会阻塞，并且可用于开发或并行执行多个调试会话。
  这还意味着在脚本调试会话完成后回滚更改，以便可以使用与上一个调试会话完全相同的KeyDB数据集再次重新启动新的调试会话。
* 另一种同步（非分叉）调试模型可以按需使用，因此可以保留对数据集的更改。在此模式下，服务器将在调试会话处于活动状态时阻塞。
* 支持分步执行。
* 支持静态和动态断点。
* 支持将调试后的脚本记录到调试器控制台中。
* 检查Lua变量。
* 跟踪脚本执行的KeyDB命令。
* KeyDB和Lua值的漂亮打印。
* 无限循环和模拟断点的长执行检测。

# 快速开始

开始使用Lua调试器的一个简单方法是通过redis观看这个视频介绍（使用相同的命令，但使用keydb而不是redis）：

**重要提示：** 请确保避免使用KeyDB生产服务器调试Lua脚本。改用开发服务器。还要注意，使用同步调试模式（这不是默认模式）会导致KeyDB服务器在调试会话持续的所有时间内阻塞。

要使用keydb-cli启动新的调试会话，请执行以下步骤：

    1.使用首选编辑器在某个文件中创建脚本。假设您正在编辑位于/tmp/script.Lua的KeyDB Lua脚本。
    
    2.启动调试会话：
        ./keydb-cli --ldb --eval /tmp/script.lua

请注意，使用keydb-cli的--eval选项，您可以将密钥名称和参数传递给脚本，并用逗号分隔，如下例所示

    ./keydb-cli --ldb --eval /tmp/script.lua mykey somekey , arg1 arg2
    
您将进入一种特殊模式，其中keydb-cli不再接受其常规命令，而是打印一个帮助屏幕，并将未修改的调试命令直接传递给keydb。

唯一没有传递给KeyDB调试器的命令是：

* exit    --这将终止调试会话。这就像删除所有断点并使用continue调试命令一样。此外，命令将从keydb-cli退出。
* restart --调试会话将从头开始，从文件中重新加载脚本的新版本。因此，正常的调试周期包括在一些调试之后修改脚本，并调用restart以便在新脚本更改后重新开始调试。
* help    --这个命令被传递给KeyDB Lua调试器，它将打印一个命令列表，如下所示：
        
    lua debugger> help
    keydb Lua debugger help:
    [h]elp               Show this help.
    [s]tep               Run current line and stop again.
    [n]ext               Alias for step.
    [c]continue          Run till next breakpoint.
    [l]list              List source code around current line.
    [l]list [line]       List source code around [line].
                         line = 0 means: current position.
    [l]list [line] [ctx] In this form [ctx] specifies how many lines
                         to show before/after [line].
    [w]hole              List all source code. Alias for 'list 1 1000000'.
    [p]rint              Show all the local variables.
    [p]rint <var>        Show the value of the specified variable.
                         Can also show global vars KEYS and ARGV.
    [b]reak              Show all breakpoints.
    [b]reak <line>       Add a breakpoint to the specified line.
    [b]reak -<line>      Remove breakpoint from the specified line.
    [b]reak 0            Remove all breakpoints.
    [t]race              Show a backtrace.
    [e]eval <code>       Execute some Lua code (in a different callframe).
    [r]edis <cmd>        Execute a KeyDB command.
    [m]axlen [len]       Trim logged KeyDB replies and Lua var dumps to len.
                         Specifying zero as <len> means unlimited.
    [a]abort             Stop the execution of the script. In sync
                         mode dataset changes will be retained.
    
    Debugger functions you can call from Lua scripts:
    keydb.debug()        Produce logs in the debugger console.
    keydb.breakpoint()   Stop execution as if there was a breakpoint in the
                         next line of code.    

请注意，启动调试器时，调试器将以**步骤模式**启动。它将在脚本的第一行停止，该行在执行之前实际执行了一些操作。

从这一点开始，您通常调用step来执行该行并转到下一行。当您执行step时，KeyDB将显示服务器执行的所有命令，如下例所示：

    * Stopped at 1, stop reason = step over
    -> 1   keydb.call('ping')
    lua debugger> step
    <KeyDB> ping
    <reply> "+PONG"
    * Stopped at 2, stop reason = step over

<KeyDB> 和 <reply> 行显示刚刚执行的行执行的命令，以及来自服务器的回复。
请注意，这仅在步进模式下发生。如果使用continue执行脚本直到下一个断点，则不会在屏幕上转储命令以防止输出过多。

## 调试会话的终止

当脚本自然终止时，调试会话结束，keydb-cli以正常的非调试模式返回。您可以像往常一样使用restart命令重新启动会话。

停止调试会话的另一种方法是按Ctrl+C手动中断keydb-cli。请注意，任何中断keydbcli和keydb服务器之间连接的事件都会中断调试会话。

当服务器关闭时，所有分叉调试会话都将终止。

## 缩写调试命令

调试可能是一个非常重复的任务。因此，每个KeyDB调试器命令都以不同的字符开头，您可以使用单个初始字符来引用该命令。

例如，您可以只键入s而不是键入step。

## 断点

如联机帮助中所述，添加和删除断点非常简单。只需使用b 1 2 3 4在第1、2、3、4行中添加断点。
命令b 0删除所有断点。所选断点可以使用要删除的断点所在的行作为参数删除，但以减号作为前缀。
例如，b-3从第3行删除断点。

请注意，向Lua从不执行的行添加断点（如局部变量或注释的声明）将不起作用。将添加断点，但由于脚本的这一部分永远不会执行，因此程序将永远不会停止。

## 动态断点

使用breakpoint命令可以将断点添加到特定行中。然而，有时我们只想在发生特殊情况时停止程序的执行。
为此，可以在Lua脚本中使用keydb.breakpoint()函数。调用时，它模拟下一行将执行的断点。

    if counter > 10 then keydb.breakpoint() end

此功能在调试时非常有用，因此我们可以避免在遇到给定条件之前手动多次继续执行脚本。

## 同步模式

如前所述，但默认LDB使用分叉会话，在调试脚本时回滚脚本操作的所有数据更改。
在调试期间，决定论通常是一件好事，这样就可以启动连续的调试会话，而无需将数据库内容重置为其原始状态。

但是，为了跟踪某些错误，您可能希望保留每个调试会话对key空间执行的更改。
当这是一个好主意时，您应该使用keydb-cli中的特殊选项ldb-sync-mode启动调试器。

    ./keydb-cli --ldb-sync-mode --eval /tmp/script.lua

**请注意，在此模式下调试会话期间，KeyDB服务器将无法访问**，因此请小心使用。

在这种特殊模式下，abort命令可以中途停止脚本对数据集进行更改。请注意，这与正常结束调试会话不同。
如果您只是中断keydb-cli，脚本将完全执行，然后会话将终止。
相反，使用abort，您可以在中间中断脚本执行，并在需要时启动新的调试会话。

## 从脚本记录

keydb.debug() 命令是一个强大的调试工具，可以在keydb Lua脚本中调用它，以便将事情记录到调试控制台中：

    lua debugger> list
    -> 1   local a = {1,2,3}
       2   local b = false
       3   keydb.debug(a,b)
    lua debugger> continue
    <debug> line 3: {1; 2; 3}, false

如果脚本是在调试会话之外执行的，keydb.debug()完全没有效果。请注意，该函数接受多个参数，这些参数在输出中由逗号和空格分隔。
正确显示表和嵌套表，以便使调试脚本的程序员易于观察值。

## 用print和eval检查程序状态

虽然可以使用keydb.debug()函数直接从Lua脚本中打印值，但在单步执行或停止到断点时观察程序的局部变量通常是有用的。

print命令就是这样做的，并在调用帧中执行查找，从当前帧开始，返回到上一个帧，直到顶层。这意味着即使我们进入Lua脚本中的嵌套函数，我们仍然可以使用print foo在调用函数的上下文中查看foo的值。
在没有变量名的情况下调用时，print将打印所有变量及其各自的值。

eval命令在当前调用框架的上下文之外执行小部分Lua脚本（当前Lua内部不可能在当前调用框架的上下文内求值）。
但是，您可以使用这个命令来测试Lua函数。

## 调试客户端

LDB使用client-server模型，其中KeyDB服务器充当使用RESP进行通信的调试服务器。
虽然keydb-cli是默认的调试客户端，但只要满足以下条件之一，就可以使用任何客户端进行调试：

* 客户端提供一个本机接口，用于设置调试模式和控制调试会话。
* 客户端提供一个接口，用于通过RESP发送任意命令。
* 客户端允许向KeyDB服务器发送原始消息。

