# 调试步骤

KeyDB的开发非常注重稳定性：我们在每次发布时都会尽力确保您体验到一个非常稳定的产品并且不会崩溃。
然而，即使我们尽了最大努力，也不可能100%成功地避免所有的关键错误。

当KeyDB崩溃时，它会生成一个关于发生了什么的详细报告，但是有时查看崩溃报告是不够的，KeyDB核心团队也不可能独立地重现问题：在这种情况下，我们需要能够重现问题的用户的帮助。

这个小指南展示了如何使用GDB来提供KeyDB开发人员更容易跟踪bug所需的所有信息。

## 什么是GDB？

GDB是Gnu调试器：能够检查另一个程序内部状态的程序。通常，跟踪和修复bug是在bug发生时收集有关程序状态的更多信息的一种练习，因此GDB是一个非常有用的工具。

GDB可以通过两种方式使用：

    * 它可以附加到正在运行的程序并在运行时检查其状态。
    * 它可以使用所谓的核心文件（即程序运行时的内存映像）检查已经终止的程序的状态。

从调查KeyDB bug的角度来看，我们需要使用这两种GDB模式：能够重现bug的用户将GDB附加到正在运行的KeyDB实例上，当崩溃发生时，他们创建core文件，然后开发人员将使用该文件在崩溃时检查KeyDB内部。
这样，开发人员就可以在不需要用户帮助的情况下在自己的计算机中执行所有检查，并且用户可以在生产环境中自由地重新启动KeyDB

## 在不进行优化的情况下编译KeyDB

默认情况下，KeyDB是使用-O2开关编译的，这意味着启用了编译器优化。这使得KeyDB可执行的速度更快，但同时也使得KeyDB（与任何其他程序一样）更难使用GDB进行检查。

最好使用make noopt命令将GDB附加到编译的KeyDB而不进行优化来编译它（而不只是使用简单的make命令）。
但是，如果您在生产环境中已经有一个正在运行的KeyDB，那么如果这会在您这边造成问题，则无需重新编译并重新启动它。
即使GDB在较小程度上仍然可以对使用优化编译的可执行文件起作用。

如果您确保在第一次崩溃后用make noopt重新编译KeyDB，那么下次跟踪这个问题会更简单，那就太好了。

您不应该担心在没有优化的情况下编译KeyDB会导致性能损失，这不太可能在您的环境中造成问题，因为KeyDB通常只是一个很小的百分比的问题，因为它不是很受CPU限制（它为查询提供大量的I/O）

## 将GDB附加到正在运行的进程

如果您有一个已经在运行的KeyDB服务器，那么可以将GDB附加到它上，这样，如果KeyDB崩溃，就可以检查内部并生成一个核心转储文件。

将GDB附加到KeyDB进程之后，它将继续正常运行，而不会损失任何性能，因此这不是一个危险的过程。

为了附加GDB，首先需要的是正在运行的KeyDB实例的进程ID（进程的pid）。您可以使用keydb-cli轻松获得它：

    $ keydb-cli info | grep process_id
    process_id:58414

在上面的例子中，进程ID是 **58414**。

* 登录到KeyDB服务器。
* （可选但建议）启动**screen**或**tmux**或任何其他程序，以确保在ssh连接超时时不会关闭GDB会话。如果你不知道屏幕是什么，帮自己一个忙，看这篇文章
* 将GDB附加到正在运行的KeyDB服务器键入：

     gdb <path-to-keydb-executable> <pid>
     
     例如：gdb /usr/local/bin/keydb-server 58414
 
GDB将启动并附加到正在运行的服务器上，打印如下内容：

    Reading symbols for shared libraries + done
    0x00007fff8d4797e6 in epoll_wait ()
    (gdb)

* 此时GDB已连接，但GDB阻止了KeyDB实例。为了让KeyDB实例继续执行，只需在GDB提示下键入**continue**，然后按enter。

     (gdb) continue
      Continuing.
  
* 完成！现在您的KeyDB实例连接了GDB。你可以等。。。下一次碰撞：）

* 现在是时候分离您的screen/tmux会话了，如果您正在使用它运行GDB，请按通常的Ctrl-a组合键。

## Crash后

KeyDB有一个命令，可以使用DEBUG SEGFAULT命令模拟分段错误（换句话说，是一个坏崩溃）（当然，不要对实际的生产实例使用它；）。
因此，我将使用此命令崩溃我的实例，以显示在GDB端发生了什么：

    (gdb) continue
    Continuing.
    
    Program received signal EXC_BAD_ACCESS, Could not access memory.
    Reason: KERN_INVALID_ADDRESS at address: 0xffffffffffffffff
    debugCommand (c=0x7ffc32005000) at debug.c:220
    220         *((char*)-1) = 'x';

正如您所看到的，GDB检测到KeyDB崩溃了，甚至可以显示导致崩溃的文件名和行号。
这已经比KeyDB crash report back trace（只包含函数名和二进制偏移量）好多了。

## 获取堆栈跟踪

首先要做的是使用GDB获得完整的堆栈跟踪。这和使用bt命令一样简单：（这是backtrace的缩写）：

    (gdb) bt
    #0  debugCommand (c=0x7ffc32005000) at debug.c:220
    #1  0x000000010d246d63 in call (c=0x7ffc32005000) at KeyDB.c:1163
    #2  0x000000010d247290 in processCommand (c=0x7ffc32005000) at KeyDB.c:1305
    #3  0x000000010d251660 in processInputBuffer (c=0x7ffc32005000) at networking.c:959
    #4  0x000000010d251872 in readQueryFromClient (el=0x0, fd=5, privdata=0x7fff76f1c0b0, mask=220924512) at networking.c:1021
    #5  0x000000010d243523 in aeProcessEvents (eventLoop=0x7fff6ce408d0, flags=220829559) at ae.c:352
    #6  0x000000010d24373b in aeMain (eventLoop=0x10d429ef0) at ae.c:397
    #7  0x000000010d2494ff in main (argc=1, argv=0x10d2b2900) at KeyDB.c:2046

这显示了回溯，但我们也希望使用info registers命令转储处理器寄存器：

    (gdb) info registers
    rax            0x0  0
    rbx            0x7ffc32005000   140721147367424
    rcx            0x10d2b0a60  4515891808
    rdx            0x7fff76f1c0b0   140735188943024
    rsi            0x10d299777  4515796855
    rdi            0x0  0
    rbp            0x7fff6ce40730   0x7fff6ce40730
    rsp            0x7fff6ce40650   0x7fff6ce40650
    r8             0x4f26b3f7   1327936503
    r9             0x7fff6ce40718   140735020271384
    r10            0x81 129
    r11            0x10d430398  4517462936
    r12            0x4b7c04f8babc0  1327936503000000
    r13            0x10d3350a0  4516434080
    r14            0x10d42d9f0  4517452272
    r15            0x10d430398  4517462936
    rip            0x10d26cfd4  0x10d26cfd4 <debugCommand+68>
    eflags         0x10246  66118
    cs             0x2b 43
    ss             0x0  0
    ds             0x0  0
    es             0x0  0
    fs             0x0  0
    gs             0x0  0

请**确保**在错误报告中**包含**这两个输出。

## 获取核心文件

下一步是生成核心转储，即运行KeyDB进程的内存映像。这是使用gcore命令执行的：

    (gdb) gcore
    Saved corefile core.58414

现在您有了要发送给KeyDB开发人员的核心转储，但必须了解，这恰好包含了崩溃时KeyDB实例中的所有数据；
KeyDB开发人员将确保不会与其他人共享内容，一旦文件不再用于调试目的，将立即删除该文件，但会警告您，通过发送核心文件，您将发送数据。

## 给开发者送什么

最后，您可以将所有内容发送给KeyDB核心团队：

* 您正在使用的KeyDB可执行文件。
* bt命令生成的堆栈跟踪和寄存器转储。
* 用gdb生成的核心文件。
* 有关正在使用的操作系统和GCC版本以及KeyDB版本的信息。

## 感谢