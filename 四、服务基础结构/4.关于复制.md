# 复制

在KeyDB复制的基础上，有一个非常简单的使用和配置leader follower（master-slave）复制：
它允许从KeyDB实例是主实例的精确副本。每次链接断开时，从服务器都会自动重新连接到主服务器，并且不管主服务器发生了什么，
它都会试图成为主服务器的精确副本。

该系统使用三种主要机制工作：

1.当主实例和从实例连接良好时，主实例通过向从实例发送命令流来保持从实例的更新，以便复制由于以下原因对数据集产生的影响：
  客户端写入、key过期或收回、更改主数据集的任何其他操作。
2.当主服务器和从服务器之间的链接断开时，由于网络问题或由于在主服务器或从服务器中检测到超时，从服务器将重新连接并尝试进行部分重新同步：
  这意味着它将尝试只获取在断开连接期间丢失的部分命令流。
3.当部分重新同步不可能时，从机将要求完全重新同步。这将涉及一个更复杂的过程，在这个过程中，主服务器需要创建其所有数据的快照，
  将其发送到从服务器，然后随着数据集的变化继续发送命令流。

KeyDB默认使用异步复制，这种复制具有低延迟和高性能，是大多数KeyDB用例的自然复制模式。
然而，KeyDB从机异步地确认它们与主机周期性地接收的数据量。因此，主服务器不会每次等待从服务器处理命令，
但是它知道，如果需要，哪个从服务器已经处理了哪个命令。这允许进行可选的同步复制。

客户端可以使用WAIT命令请求某些数据的同步复制。但是，WAIT只能确保其他KeyDB实例中存在指定数量的已确认副本，
它不会将一组KeyDB实例转换为具有强一致性的CP系统：根据KeyDB持久性的确切配置，在故障转移期间，已确认的写操作仍然可能丢失。
但是，随着等待，在发生故障事件后丢失写操作的概率将大大降低到某些难以触发的故障模式。

您可以查看Sentinel或KeyDB集群文档，了解有关高可用性和故障转移的更多信息。不过，我们鼓励从主动复制开始，因为它使用简单，而且是一个实现高可用性的强大工具。
本文的其余部分主要描述KeyDB基本复制的基本特性。

以下是有关KeyDB复制的一些非常重要的事实：

* KeyDB使用异步复制，异步slave-to-master确认处理的数据量。一个master可以有多个slave。
* Slave从机可以接受来自其他从机的连接。除了将多个从机连接到同一个主机之外，从机还可以以级联结构连接到其他从机。
  自KeyDB 4.0以来，所有的子从服务器都将从主服务器接收完全相同的复制流。
* KeyDB复制在主端是非阻塞的。这意味着当一个或多个从机执行初始同步或部分重新同步时，主机将继续处理查询。
* 从机端的复制也基本上是无阻塞的。当从机执行初始同步时，它可以使用旧版本的数据集处理查询，假设您在redis.conf中配置了KeyDB，
  否则，您可以配置KeyDB从机在复制流关闭时向客户端返回错误。但是，在初始同步之后，必须删除旧数据集并加载新数据集。
  在这个简短的窗口期间，从机将阻止传入的连接（对于非常大的数据集，这可能长达数秒）。由于KeyDB 4.0，可以配置KeyDB，以便在不同的线程中删除旧数据集，但是加载新的初始数据集仍将在主线程中进行，并阻止从线程。
* 复制既可以用于可伸缩性，以便有多个从机用于只读查询（例如，可以将缓慢的O（N）操作卸载到从机），也可以仅用于提高数据安全性和高可用性。
* 可以使用复制来避免让主机将完整数据集写入磁盘的成本：典型的技术包括配置master redis.conf以完全避免持久化到磁盘，然后连接一个配置为不时保存或启用aof的从机。
* 但是，必须小心处理此设置，因为重新启动主服务器将以空数据集开始：如果从服务器尝试与其同步，则从服务器也将被清空。

## 主服务器关闭持久性时的复制安全性

在使用KeyDB复制的设置中，强烈建议在主设备和从设备中启用持久性。如果这是不可能的，例如由于非常慢的磁盘引起的延迟问题，则应将实例配置为避免在重新启动后自动重新启动。

为了更好地理解为什么将持久性关闭并配置为自动重启的主服务器是危险的，请检查以下故障模式，其中数据将从主服务器及其所有从服务器中擦除：

1.我们有一个设置，节点A充当主节点，拒绝持久性，节点B和C从节点A复制。
2.节点A崩溃，但是它有一些自动重启系统，可以重启进程。但是，由于关闭了持久性，节点将使用空数据集重新启动。
3.节点B和C将从节点A复制数据，节点A为空，因此它们将有效地销毁数据的副本。

## KeyDB复制的工作原理

每个KeyDB master都有一个复制ID：它是一个大的伪随机字符串，用于标记数据集的给定故事。
每个主服务器还接受一个偏移量，该偏移量为复制流的每个字节递增，复制流生成后将发送到从服务器，以便用修改数据集的新更改更新从服务器的状态。
即使没有实际连接从机，复制偏移量也会增加，因此基本上每个给定的对:

    Replication ID, offset

标识主数据集的确切版本。

当从机连接到主机时，它们使用PSYNC命令发送旧的主复制ID和迄今为止处理的偏移量。这样主服务器就可以发送所需的增量部分。
但是，如果主缓冲区中没有足够的backlog，或者如果从机引用的是不再已知的历史（复制ID），则会发生完全重新同步：在这种情况下，从机将从头获得数据集的完整副本。

完整同步的工作原理如下：
主机启动后台保存过程以生成RDB文件。同时，它开始缓冲从客户机接收的所有新写命令。后台保存完成后，主服务器将数据库文件传输到从服务器，从服务器将其保存在磁盘上，然后将其加载到内存中。
然后，主服务器将所有缓冲命令发送给从服务器。这是以命令流的形式完成的，并且与KeyDB协议本身的格式相同。

你可以通过telnet自己试试。在服务器执行某些工作时连接到KeyDB端口并发出SYNC命令。
您将看到一个大容量传输，然后主服务器接收到的每个命令都将在telnet会话中重新发出。
实际上，SYNC是一个旧协议，不再被较新的KeyDB实例使用，但仍然存在向后兼容性：它不允许部分重新同步，因此现在改为使用PSYNC。

如前所述，当主从链路因某种原因断开时，从机能够自动重新连接。如果主服务器接收到多个并发的从服务器同步请求，它将执行单个后台保存以服务于所有这些请求。

## 复制ID说明

在上一节中，我们说过，如果两个实例具有相同的复制ID和复制偏移量，则它们具有完全相同的数据。
但是，理解什么是复制ID以及为什么实例实际上有两个复制ID（主ID和辅助ID）是非常有用的。

复制ID基本上标记数据集的给定历史记录。每次实例以主实例重新启动，或从实例升级为主实例时，都会为此实例生成一个新的复制ID。
与主服务器连接的从服务器将在握手后继承其复制ID。因此，具有相同ID的两个实例是相关的，因为它们持有相同的数据，但可能在不同的时间。
对于保存最新数据集的给定历史记录（复制ID），它是作为逻辑时间来理解的偏移量。

例如，如果两个实例A和B具有相同的复制ID，但其中一个具有偏移量1000，另一个具有偏移量1023，这意味着第一个实例缺少应用于数据集的某些命令。
这也意味着，通过应用几个命令，A可以达到与B完全相同的状态。

KeyDB实例有两个复制id的原因是因为提升为master的从机。在故障转移之后，提升的从属服务器仍然需要记住它以前的复制ID是什么，
因为这样的复制ID是以前的主服务器之一。这样，当其他从机将与新的主机同步时，它们将尝试使用旧的主复制ID执行部分重新同步。
这将按预期工作，因为当从机升级到主机时，它将其辅助ID设置为其主ID，并记住发生此ID切换时的偏移量。
稍后，它将选择一个新的随机复制ID，因为新的历史记录将开始。当处理新的从机连接时，为了安全起见，主机将把它们的ID和偏移量与当前ID和辅助ID（直到给定的偏移量）相匹配。
简而言之，这意味着在故障转移之后，连接到新升级主服务器的从属服务器不必执行完全同步。

如果您想知道为什么提升为主服务器的从服务器在故障转移后需要更改其复制ID：由于某些网络分区，旧主服务器可能仍在作为主服务器工作：保留相同的复制ID将违反以下事实：
任意两个随机实例的相同ID和相同偏移量意味着它们具有相同的数据准备好了。

## 无盘复制

通常，完全重新同步需要在磁盘上创建一个RDB文件，然后从磁盘重新加载相同的RDB，以便向从机提供数据。

对于慢速磁盘，这对主磁盘来说可能是一个压力很大的操作。KeyDB版本2.8.18是第一个支持无盘复制的版本。
在此设置中，子进程直接通过线路将RDB发送到从属进程，而不使用磁盘作为中间存储

## 配置

配置基本KeyDB复制很简单：只需将以下行添加到从配置文件：

    slaveof 192.168.1.1 6379
        
当然，您需要用主IP地址（或主机名）和端口替换192.168.1.16379。或者，您可以调用SLAVEOF命令，主主机将启动与从机的同步。

还有一些参数用于调整主服务器在内存中获取的复制积压工作，以执行部分重新同步。
有关更多信息，请参见KeyDB发行版附带的示例redis.conf。

可以使用repl-diskless-sync配置参数启用无盘复制。启动传输以等待第一个从机到达的延迟由repl-diskless-sync-delay参数控制。
有关详细信息，请参阅KeyDB发行版中的示例redis.conf文件。    

## slave Read-only只读
 
由于KeyDB 2.6，从机支持默认启用的只读模式。此行为由redis.conf文件中的slave-read-only选项控制，并且可以在运行时使用CONFIG SET启用和禁用。

只读从机将拒绝所有写命令，因此不可能因为错误而向从机写入。这并不意味着该特征旨在将从属实例暴露到因特网或更一般地存在于不信任客户端存在的网络中，
因为仍允许启用诸如调试或配置之类的管理命令。但是，通过使用rename command指令禁用redis.conf中的命令，可以提高只读实例的安全性。

您可能想知道为什么可以还原只读设置，并拥有可由写操作作为目标的从属实例。如果从机和主机重新同步或从机重新启动，则这些写操作将被丢弃，
但在可写从机中存储临时数据有一些合法的用例。

例如，计算慢集或排序集操作并将其存储到本地密钥是多次观察到的可写从机的一个用例。

但是请注意，版本4.0之前的可写从属服务器无法在设置了生存时间的情况下使key过期。这意味着，如果使用期满或其他命令为密钥设置最大TTL，则key将泄漏，
而当您在读取命令时访问它时，您将不再看到它，您将在密钥计数中看到它，并且它仍将使用内存。所以一般来说，混合可写奴隶（前4版）和TTL key会产生问题。

KeyDB 4.0rc3和更高版本完全解决了这个问题，现在可写的从机可以像主机那样用TTL逐出key，
但以大于63的DB号写入的key除外（但默认情况下KeyDB实例只有16个数据库）。

还要注意，由于KeyDB 4.0从机写操作只是本地的，不会传播到附加到实例的子从机。
子从机将始终接收与顶级主机发送给中间从机的复制流相同的复制流。例如，在以下设置中：
 
    A ---> B ---> C
 
即使B是可写的，C也不会看到B写操作，而是拥有与主实例A相同的数据集。
 
## 设置从机以向主机进行身份验证

如果您的主服务器通过requirepass有一个密码，那么将从服务器配置为在所有同步操作中使用该密码是很简单的。
要在正在运行的实例上执行此操作，请使用keydb-cli并键入：

    config set masterauth <password>

要永久设置它，请将其添加到配置文件中：

    masterauth <password>
    
## 只允许对N个附加副本执行写操作

从KeyDB 2.8开始，只有当至少N个从服务器当前连接到主服务器时，才可以将KeyDB主服务器配置为接受写查询。
但是，由于KeyDB使用异步复制，因此无法确保从机实际接收到给定的写入，因此始终存在一个数据丢失窗口。
这就是该功能的工作原理：

* KeyDB从服务器每秒ping主服务器，确认处理的复制流的数量。
* KeyDB主服务器将记住上次从每个从服务器接收ping的时间。
* 用户可以配置具有不大于最大秒数的滞后的最小数量的奴隶

如果至少有N个从机，且延迟小于M秒，则将接受写入。

您可能认为它是一种尽力而为的数据安全机制，在这种机制中，对于给定的写操作，不保证一致性，但至少数据丢失的时间窗口被限制在给定的秒数内。一般来说，绑定数据丢失比未绑定数据丢失要好。

如果不满足这些条件，则主服务器将返回一个错误，并且不接受写入。

此功能有两个配置参数：

* min-slaves-to-write <number of slaves>
* min-slaves-max-lag  <number of seconds>

有关更多信息，请检查KeyDB源发行版附带的示例redis.conf文件。

## KeyDB复制如何处理key过期

KeyDB expires允许key具有有限的生存时间。这样的特性取决于实例计算时间的能力，但是KeyDB从机可以使用expires正确地复制key，即使使用Lua脚本更改了这些key。

为了实现这样的功能，KeyDB不能依赖于主从机具有同步时钟的能力，因为这是一个无法解决的问题，会导致竞争条件和数据集发散，
因此KeyDB使用三种主要技术来使过期key的复制能够工作：

1.从服务器不会使key过期，而是等待主服务器使key过期。当主key过期（或由于LRU而逐出它）时，它将合成一个DEL命令，该命令将被传输到所有从机。

2.但是，由于主驱动过期，有时从机可能仍有逻辑过期的内存键，因为主机无法及时提供DEL命令。
为了处理奴隶使用它的逻辑时钟，以便报告一个key不存在只用于不违反数据集一致性的读取操作（因为来自主机的新命令将到达）。
以这种方式，奴隶避免报告逻辑过期的key仍然存在。实际上，使用从缓存进行扩展的HTML片段缓存将避免返回比预期生存时间早的项。

3.在Lua脚本执行期间，不执行任何key过期。作为一个LUA脚本运行，从概念上讲，主机中的时间被冻结，因此给定的key在脚本运行的所有时间中都将存在或不存在。
这可以防止key在脚本中间过期，并且需要密钥才能以保证在数据集中具有相同效果的方式将相同的脚本发送到从属服务器。

一旦从机升级到主机，它将开始独立地终止key，并且不需要旧主机的任何帮助。

## 在Docker和NAT中配置复制

当使用Docker或使用端口转发或网络地址转换的其他类型容器时，KeyDB复制需要一些额外的注意，特别是当使用KeyDB Sentinel或其他系统时，在这些系统中，主信息或角色命令输出被扫描以发现从机地址。

问题是，当向主实例发出ROLE命令和INFO输出的replication部分时，将显示从实例具有用于连接到主实例的IP地址，在使用NAT的环境中，这可能与从实例的逻辑地址（客户端应用于连接到的地址）不同奴隶）。

类似地，在redis.conf中配置了监听端口的情况下，将列出从属服务器，如果端口被重新映射，则监听端口可能与转发端口不同。

为了解决这两个问题，由于KeyDB 3.2.2，有可能强制从机向主机宣布任意一对IP和端口。要使用的两个配置指令是：

    slave-announce-ip 5.5.5.5
    slave-announce-port 1234

并记录在最近KeyDB发行版的示例redis.conf中。

## INFO 和 ROLE命令

有两个KeyDB命令提供了关于主实例和从实例的当前复制参数的大量信息。
一个是INFO。如果使用replication参数作为INFO replication调用该命令，则只显示与复制相关的信息。
另一个对计算机更友好的命令是ROLE，它提供主设备和从设备的复制状态以及它们的复制偏移量、连接的从设备列表等。

## 重新启动和故障转移后的部分重新同步

由于KeyDB 4.0，当一个实例在故障转移后升级为master时，它仍然能够与旧master的从机执行部分重新同步。
要做到这一点，从机会记住旧的复制ID和它以前主机的偏移量，因此即使连接的从机请求旧的复制ID，也可以向连接的从机提供部分backlog。

但是，提升的从机的新复制ID将有所不同，因为它构成了数据集的不同历史记录。例如，主服务器可以返回可用数据，并可以在一段时间内继续接受写入，因此在升级的从服务器中使用相同的复制ID将违反复制ID和偏移量对仅标识单个数据集的规则。

此外，从机在轻轻关闭电源并重新启动后，能够在RDB文件中存储与主机重新同步所需的信息。
这在升级时很有用。如果需要，最好使用SHUTDOWN命令在从机上执行save & quit操作。

不可能部分重新同步通过AOF文件重新启动的从机。但是，在关闭实例之前，可以将其转换为RDB持久性，然后可以重新启动，最后可以再次启用AOF。

