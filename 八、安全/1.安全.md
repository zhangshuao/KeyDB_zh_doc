# 安全

本文从KeyDB的角度介绍了安全主题：KeyDB提供的访问控制、代码安全问题、通过选择恶意输入从外部触发的攻击以及其他类似主题。

对于与安全相关的联系人，请在GitHub上打开一个问题。

## KeyDB通用安全模型

KeyDB设计为可由受信任环境中的受信任客户端访问。这意味着通常情况下，将KeyDB实例直接公开到internet或通常公开到不受信任的客户端可以直接访问KeyDB TCP端口或UNIX套接字的环境中不是一个好主意。
例如，在使用KeyDB作为数据库、缓存或消息传递系统实现的web应用程序的公共上下文中，应用程序前端（web侧）内的客户端将查询KeyDB以生成页面或执行web应用程序用户请求或触发的操作。
在这种情况下，web应用程序在KeyDB和不受信任的客户端（访问web应用程序的用户浏览器）之间进行中介访问。
这是一个特定的示例，但是，一般来说，对KeyDB的不受信任访问应该始终由实现acl、验证用户输入和决定对KeyDB实例执行什么操作的层进行中介。
一般来说，KeyDB不是为了最大安全性而优化，而是为了最大化性能和简单性。

## 网络安全

除了网络中受信任的客户端之外，每个人都应该拒绝对KeyDB端口的访问，因此运行KeyDB的服务器应该只能由使用KeyDB实现应用程序的计算机直接访问。

在直接暴露于internet的单个计算机的常见情况下，例如虚拟化Linux实例（Linode、EC2，…），
KeyDB端口应采用防火墙，以防止外部访问。客户端仍然可以使用环回接口访问KeyDB。

注意，可以通过在redis.conf文件中添加如下行将KeyDB绑定到单个接口：

    bind 127.0.0.1

由于KeyDB的性质，不能从外部保护KeyDB端口可能会产生很大的安全影响。例如，外部攻击者可以使用单个**FLUSHALL**命令删除整个数据集。

## 保护模式

不幸的是，许多用户无法保护KeyDB实例不被外部网络访问。许多实例只是通过公共IP暴露在互联网上。
由于这个原因，从3.2.0版开始，当KeyDB以默认配置（绑定所有接口）执行并且没有任何密码来访问它时，它会进入一种称为保护模式的特殊模式。
在这种模式下，KeyDB只回复来自环回接口的查询，并回复来自其他地址的其他客户机连接时出错，解释发生了什么以及如何正确配置KeyDB。

我们期望protected mode可以大大减少由于未经适当管理而执行的未受保护的KeyDB实例所导致的安全问题，但是系统管理员仍然可以忽略KeyDB所给出的错误，
而只需禁用protected mode或手动绑定所有接口。

## 身份验证功能

虽然KeyDB没有尝试实现访问控制，但它提供了一个很小的身份验证层，可以选择打开它来编辑redis.conf文件。

启用授权层后，KeyDB将拒绝未经身份验证的客户端的任何查询。客户端可以通过发送AUTH命令和密码来验证自己。

密码由系统管理员在redis.conf文件中以明文设置。它应该足够长，以防止暴力攻击有两个原因：

    * KeyDB在服务查询方面非常快。每秒可以由外部客户端测试许多密码。
    * KeyDB密码存储在redis.conf文件和客户端配置中，因此系统管理员不需要记住它，因此它可能很长。

认证层的目标是可选地提供一个冗余层。如果防火墙或为保护KeyDB免受外部攻击者攻击而实现的任何其他系统失败，则在不知道身份验证密码的情况下，外部客户端仍然无法访问KeyDB实例。
AUTH命令和其他KeyDB命令一样，都是未加密发送的，因此它无法抵御对网络具有足够访问权限以执行窃听的攻击者。

## 数据加密支持

KeyDB不支持加密。为了实现受信任方可以通过internet或其他不受信任的网络访问KeyDB实例的设置，
应实现额外的保护层，例如SSL代理。我们建议透传。

## 禁用特定命令

可以禁用KeyDB中的命令，或将其重命名为不可访问的名称，以便将普通客户端限制为指定的命令集。

例如，虚拟化服务器提供者可以提供托管KeyDB实例服务。在此上下文中，普通用户可能无法调用KeyDB CONFIG命令来更改实例的配置，但是提供和删除实例的系统应该能够这样做。

在这种情况下，可以从命令表中重命名或完全隐藏命令。此功能作为语句提供，可以在redis.conf配置文件中使用。例如：

    rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52

在上面的示例中，CONFIG命令被重命名为不可使用的名称。也可以通过将其重命名为空字符串来完全禁用它（或任何其他命令），如下例所示：

    rename-command CONFIG ""

## 由外部客户端精心选择的输入触发的攻击

即使没有对实例的外部访问，攻击者也可以从外部触发一类攻击。这种攻击的一个例子是将数据插入到KeyDB中，从而触发在KeyDB内部结构中实现的数据结构的病理（最坏情况）算法复杂度。

例如，攻击者可以通过web表单提供一组已知的字符串，这些字符串散列到同一个存储桶中，从而将O（1）预期时间（平均时间）转换为O（N）最坏情况，消耗的CPU超过预期，并最终导致拒绝服务。

为了防止这种特定攻击，KeyDB对hash函数使用每次执行的伪随机种子。

KeyDB使用qsort算法实现SORT命令。目前，该算法并不是随机的，因此通过仔细选择合适的输入集可以触发二次最坏情况行为。

## 字符串转义和NoSQL注入

KeyDB协议没有字符串转义的概念，因此在正常情况下，使用普通的客户端库无法进行注入。
该协议使用前缀长度字符串，完全是二进制安全的。

EVAL和EVALSHA命令执行的Lua脚本遵循相同的规则，因此这些命令也是安全的。

虽然这将是一个非常奇怪的用例，但是应用程序应该避免使用从不可信源获得的字符串组成Lua脚本的主体。

## 代码安全性

在经典的KeyDB设置中，允许客户端完全访问命令集，但是访问实例永远不会导致控制KeyDB运行的系统的能力。

在内部，KeyDB使用所有众所周知的做法来编写安全代码，以防止缓冲区溢出、格式错误和其他内存损坏问题。
但是，使用CONFIG命令控制服务器配置的能力使客户端能够更改程序的工作目录和转储文件的名称。
这允许客户端以随机路径写入RDB KeyDB文件，这是一个安全问题，可能很容易导致在KeyDB运行的同一用户同时危害系统和/或运行不受信任的代码。

KeyDB不需要根权限即可运行。建议将其作为仅用于此目的的无特权KeyDB用户运行。KeyDB作者目前正在研究添加新配置参数以防止CONFIG SET/GET dir和其他类似的运行时配置指令的可能性。
这将防止客户端强制服务器在任意位置写入KeyDB转储文件。

