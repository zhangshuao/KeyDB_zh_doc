# 使用 ACL列表

KeyDB ACL是访问控制列表的缩写，它允许根据可以执行的命令和可以访问的键来限制某些连接。
其工作方式是，在连接之后，客户端需要通过提供用户名和有效密码的身份验证：如果身份验证阶段成功，则连接与给定用户关联，并且用户具有限制。
KeyDB可以被配置成新的连接已经通过"默认"用户的身份验证（这是默认配置），因此配置默认用户有一个副作用，即只能为未经显式身份验证的连接提供特定的功能子集。

在默认配置中，KeyDB 6（拥有ACL的第一个版本）的工作方式与旧版本的KeyDB完全相同，即每个新连接都能够调用每个可能的命令并访问每个key，因此ACL功能与旧客户端和应用程序向后兼容。
同样，使用requirepass配置指令配置密码的旧方法仍然按预期工作，但现在它所做的只是为默认用户设置密码。

KeyDB AUTH命令是在KeyDB 6中扩展的，因此现在可以在两个参数形式中使用它：

    AUTH <username> <password>

按旧形式使用时，即：

    AUTH <password>

发生的情况是，用于身份验证的用户名是"default"的，因此仅指定密码意味着我们要针对默认用户进行身份验证。
这提供了与过去完美的向后兼容性。

## 当ACL有用时

在使用ACL之前，您可能想问问自己，通过实现这一层保护，您希望实现的目标是什么。通常，ACL有两个主要目标：

您希望通过限制对命令和key的访问来提高安全性，以便不受信任的客户端没有访问权限，而受信任的客户端只有对数据库的最低访问级别才能执行所需的工作。
例如，某些客户端可能只能执行只读命令。

您希望提高操作安全性，以便由于软件错误或手动错误，不允许进程或人员访问KeyDB来损坏数据或配置。
例如，从KeyDB获取延迟作业的worker没有理由调用FLUSHALL命令。

ACL的另一个典型用法与托管KeyDB实例有关。KeyDB通常是作为托管服务提供的，既可以由为其拥有的其他内部客户处理KeyDB基础设施的内部公司团队提供，
也可以由云提供商在软件即服务设置中提供。在这两种设置中，我们希望确保排除客户的配置命令。过去通过命令重命名实现这一点的方法是一种技巧，它允许我们在没有ACL的情况下生存很长一段时间，但并不理想。

## 使用ACL命令配置ACL

ACL是使用DSL（领域特定语言）定义的，DSL描述给定用户能够做什么或不能做什么。这些规则总是从第一个到最后一个，从左到右实现，因为有时候规则的顺序对于理解用户真正能够做什么很重要。

默认情况下，只有一个用户定义，称为默认值。我们可以使用ACL LIST命令检查当前活动的ACL，并验证新启动和未配置的KeyDB实例的配置是：

    > ACL LIST
    1) "user default on nopass ~* +@all"

上面的命令以KeyDB配置文件中使用的相同格式报告用户列表，方法是将为用户设置的当前acl转换回其描述中。

每行的前两个单词是"user"，后跟用户名。接下来是描述不同事物的ACL规则。我们将详细介绍规则是如何工作的，但现在可以说默认用户配置为活动（on）、不需要密码（nopass）、访问每个可能的密钥（~*）并能够调用每个可能的命令（+@all）。

另外，在默认用户的特殊情况下，拥有nopass规则意味着新连接将自动通过默认用户的身份验证，而不需要任何显式的身份验证调用。

## ACL 规则

以下是有效ACL规则的列表。某些规则只是用于激活或删除标志或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或cagetories名称、键模式等连接在一起。

    启用和禁用用户：
    打开：启用用户：可以作为此用户进行身份验证。
    关闭：禁用用户：无法再与此用户进行身份验证，但是已验证的连接仍将工作。请注意，如果默认用户被标记为off，则新连接将启动而不进行身份验证，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证，而不管默认用户配置如何。

允许和禁止命令：

* +<command>：将命令添加到用户可以调用的命令列表中。
* -<command>：将命令移到用户可以调用的命令列表中。
* +@<category>：添加此类别中所有要由用户调用的命令，有效类别为@admin，@set，@sortedset。。。等等，通过调用ACL CAT命令查看完整列表。特殊类别@all意味着所有的命令，既有当前服务器中的命令，也有将来将通过模块加载的命令。
* -@<category>：类似于+@<category>，但从客户端可以调用的命令列表中删除命令。
* +<command>|子命令：允许其他禁用命令的特定子命令。请注意，此表单不允许作为-DEBUG | SEGFAULT这样的负数，而只能作为以“+”开头的加法。如果命令已作为一个整体处于活动状态，则此ACL将导致错误。
* allcommands:别名为“+@all”。注意，它意味着能够执行通过模块系统加载的所有未来命令。
* nocommands:别名-@all。

允许和禁止某些键：

* ~<pattern>：添加可以作为命令一部分提及的键模式。例如~*允许所有的键。该模式是一个全球性的模式一样的关键之一。可以指定多个模式。
* allkeys:~*的别名。
* resetkeys：刷新允许的键模式列表。例如，ACL~foo:*~bar:*resetkeys~objects:*，将导致客户端只能访问与模式对象：*匹配的密钥。

为用户配置有效密码：
* ><password>：将此密码添加到用户的有效密码列表中。例如，>mypass会将"mypass"添加到有效密码列表中。此指令清除nopass标志（请参阅下文）。每个用户可以有任意数量的密码。
* <<password>：从有效密码列表中删除此密码。如果您试图删除的密码实际上未设置，则会发出错误消息。
* nopass：删除用户的所有设置密码，并将用户标记为不需要密码：这意味着每个密码都将对该用户起作用。如果此指令用于默认用户，则每个新连接都将立即使用默认用户进行身份验证，而不需要任何显式的AUTH命令。注意resetpass指令将清除此条件。
* resetpass：刷新允许的密码列表。此外，删除nopass状态。resetpass之后，用户没有关联的密码，没有添加密码（或稍后将其设置为nopass）就无法进行身份验证。

注意：没有nopass标记、没有有效密码列表的使用实际上是不可能使用的，因为将无法以这样的用户身份登录。

重置用户：
* reset 执行以下操作：resetpass、resetkeys、off、@all。用户在创建后立即返回到其所处的状态。

## 使用ACL SETUSER命令创建和编辑用户ACL

用户可以通过两种主要方式创建和修改：

1.使用ACL命令及其ACL SETUSER子命令。
2.修改服务器配置（可以在其中定义用户）并重新启动服务器，或者如果我们使用的是外部ACL文件，则只需发出ACL加载。

在本节中，我们将学习如何使用ACL命令定义用户。有了这些知识，通过配置文件执行相同的操作将变得很简单。
在配置中定义用户应该有自己的部分，稍后将单独讨论。

首先，让我们尝试最简单的ACL SETUSER命令调用：

    > ACL SETUSER alice
    OK

SETUSER命令获取要应用于用户的用户名和ACL规则列表。但是在上面的例子中，我根本没有指定任何规则。这将只创建用户如果它不存在，使用缺省属性的只是创建使用。
如果用户已经存在，上面的命令将完全不起作用。

让我们检查一下默认用户状态是什么：

    > ACL LIST
    1) "user alice off -@all"
    2) "user default on nopass ~* +@all"
    
刚刚创建的用户"alice"是：

* 处于关闭状态，即禁用。身份验证将不起作用。
* 无法访问任何命令。请注意，默认情况下创建的用户没有访问任何命令的能力，因此上面输出中的-@all可以省略，但是ACL LIST尝试显式而不是隐式。
* 最后，没有用户可以访问的关键模式。
* 用户也没有设置密码。

这样的用户是完全无用的。让我们尝试定义用户，使其处于活动状态，具有密码，并且只能使用GET命令访问以字符串"cached:"开头的key名。

    > ACL SETUSER alice on >p1pp0 ~cached:* +get
    OK

现在用户可以做一些事情，但会拒绝做其他事情：

    > AUTH alice p1pp0
    OK
    > GET foo
    (error) NOPERM this user has no permissions to access one of the keys used as arguments
    > GET cached:1234
    (nil)
    > SET cached:1234 zap
    (error) NOPERM this user has no permissions to run the 'set' command or its subcommnad

一切如期进行。为了检查用户alice的配置（记住用户名是区分大小写的），可以使用ACL LIST的替代品，该替代品设计为更适合计算机读取，
而ACL LIST则更偏向于人类。

    > ACL GETUSER alice
    1) "flags"
    2) 1) "on"
    3) "passwords"
    4) 1) "p1pp0"
    5) "commands"
    6) "-@all +get"
    7) "keys"
    8) 1) "cached:*"

ACL GETUSER返回一个字段值数组，用更可解析的术语描述用户。输出包括标志集、密钥模式列表、密码等。
如果使用RESP3，则输出可能更具可读性，因此它将作为map reply返回：

    > ACL GETUSER alice
    1# "flags" => 1~ "on"
    2# "passwords" => 1) "p1pp0"
    3# "commands" => "-@all +get"
    4# "keys" => 1) "cached:*"

注意：从现在起，我们将继续使用KeyDB默认协议版本2，因为社区切换到新协议需要一些时间。

使用另一个ACL SETUSER命令（来自其他用户，因为alice无法运行ACL命令），我们可以向用户添加多个模式：

    > ACL SETUSER alice ~objects:* ~items:* ~public:*
    OK
    > ACL LIST
    1) "user alice on >p1pp0 ~cached:* ~objects:* ~items:* ~public:* -@all +get"
    2) "user default on nopass ~* +@all"

内存中的用户表示现在和我们预期的一样.

## 多次调用ACL SETUSER会发生什么

理解当多次调用ACL SETUSER时会发生什么非常重要。要知道的是，每个SETUSER调用不会重置用户，而是将ACL规则应用到现有用户。
只有在以前不知道的情况下才重置用户：在这种情况下，使用零ACL创建一个全新的用户，即用户不能执行任何操作、被禁用、没有密码等等：为了安全起见，这是最好的默认设置。

但是，稍后的调用将只是增量地修改用户，例如以下序列：

    > ACL SETUSER myuser +set
    OK
    > ACL SETUSER myuser +get
    OK

将导致myuser能够调用GET和SET：

    > ACL LIST
    1) "user default on nopass ~* +@all"
    2) "user myuser off -@all +set +get"

## 具有命令类别的播放

通过一个接一个地指定所有命令来设置用户acl真的很烦人，所以我们这样做：

    > ACL SETUSER yourname on +@all -@dangerous >somepassword ~*

通过说+@all和-@dangerous，我们包含了所有命令，然后删除了KeyDB命令表中标记为dangerous的所有命令。
请注意，除了"+@all"，命令类别从不包含模块commnad。如果你说+@所有的命令都可以由用户执行，甚至以后的命令都可以通过模块系统加载。
但是，如果使用ACL rule++@readonly 或任何其他规则，则始终排除modules命令。这一点非常重要，因为您应该只信任KeyDB内部命令表以确保其健全性。
模块我暴露危险的东西，在一个ACL的情况下，它只是一个加法，也就是说，以+@all-。。。你应该绝对确信你永远不会把你不想说的包括在内。

但是，要记住定义了类别，并且每个类别确切包含了哪些命令，这是不可能的，而且会非常枯燥，因此KeyDB ACL命令将导出CAT子命令，该子命令可以以两种形式使用：

    ACL CAT -- Will just list all the categories available
    ACL CAT <category-name> -- Will list all the commands inside the category

例子:

    > ACL CAT
     1) "keyspace"
     2) "read"
     3) "write"
     4) "set"
     5) "sortedset"
     6) "list"
     7) "hash"
     8) "string"
     9) "bitmap"
    10) "hyperloglog"
    11) "geo"
    12) "stream"
    13) "pubsub"
    14) "admin"
    15) "fast"
    16) "slow"
    17) "blocking"
    18) "dangerous"
    19) "connection"
    20) "transaction"
    21) "scripting"

到目前为止，您可以看到有21个不同的类别。现在，让我们检查哪些命令是geo类别的一部分：

    > ACL CAT geo
    1) "geohash"
    2) "georadius_ro"
    3) "georadiusbymember"
    4) "geopos"
    5) "geoadd"
    6) "georadiusbymember_ro"
    7) "geodist"
    8) "georadius"

请注意，命令可能是多个类别的一部分，因此例如，+@geo-@read only之类的ACL规则将导致某些geo命令被排除，因为它们是只读命令。

### 添加子命令

通常，将命令作为一个整体排除或包含的能力是不够的。许多KeyDB命令基于作为参数传递的子命令执行多个操作。例如，可以使用客户机命令执行危险和非危险操作。许多部署可能不愿意为非管理级别的用户提供执行客户端终止的能力，但可能仍然希望他们能够运行客户端SETNAME。

注意：可能新的RESP3 HELLO命令很快就会提供SETNAME选项，但无论如何这仍然是一个很好的exmaple。

在这种情况下，我可以通过以下方式更改用户的ACL：

    ACL SETUSER myuser -client +client|setname +client|getname

我开始删除CLIENT命令，后来添加了两个允许的子命令。请注意，不能执行相反的操作，只能添加子命令，而不能排除子命令，
因为将来可能会添加新的子命令：指定对某些用户有效的所有子命令要安全得多。
此外，如果添加了有关尚未禁用的命令的子命令，则会生成错误，因为这可能只是ACL规则中的一个错误：

    > ACL SETUSER default +debug|segfault
    (error) ERR Error in ACL SETUSER modifier '+debug|segfault': Adding a
    subcommand of a command already fully added is not allowed. Remove the
    command to start. Example: -DEBUG +DEBUG|DIGEST

注意，子命令匹配可能会增加一些性能损失，但是即使使用合成基准也很难测量这种损失，而且只有在调用此类命令时才会支付额外的CPU开销，
而在调用其他命令时不会支付额外的CPU开销。

### +@all VS -@all

    在上一节中，我们看到了如何在添加/删除单个命令的基础上定义命令acl。
    
